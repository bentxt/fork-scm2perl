#
# This parser was generated with
# Parse::RecDescent version 1.967015
#

package ScmToPerl::Grammar;
use Parse::RecDescent;
{ my $ERRORS;


package Parse::RecDescent::ScmToPerl::Grammar;
use strict;
use vars qw($skip $AUTOLOAD  );
@Parse::RecDescent::ScmToPerl::Grammar::ISA = ();
$skip = '\\s*';


#   use re 'eval';
   $Parse::RecDescent::tokensep = '(?:\s*(?:(;[^\n]*\n))?)*';

   my $indent = 0;
   my %sf2pf = (
      'SF-IMAGE'	=> 'PF_IMAGE,     ',
      'SF-LAYER'	=> 'PF_LAYER,     ',
      'SF-CHANNEL'	=> 'PF_CHANNEL,   ',
      'SF-VALUE'	=> 'PF_VALUE,     ',
      'SF-TOGGLE'	=> 'PF_TOGGLE,    ',
      'SF-DRAWABLE'	=> 'PF_DRAWABLE,  ',
      'SF-STRING'	=> 'PF_STRING,    ',
      'SF-COLOR'	=> 'PF_COLOUR,    ',
      'SF-ADJUSTMENT'	=> 'PF_ADJUSTMENT,',
      'SF-FONT'		=> 'PF_FONT,      ',
      'SF-PATTERN'	=> 'PF_PATTERN,   ',
      'SF-GRADIENT'	=> 'PF_GRADIENT,  ',
      'SF-FILENAME'	=> 'PF_FILE,      ',
   );
   my %constant = qw(
      TRUE		1
      FALSE		0
      #t		1
      #f		0

      RGB		RGB_IMAGE
      RGBA		RGBA_IMAGE

      LINEAR		LINEAR_INTERPOLATION

      NORMAL		NORMAL_MODE
      ADDITION		ADDITION_MODE
      MULTIPLY		MULTIPLY_MODE
      DIFFERENCE	DIFFERENCE_MODE
      DARKEN_ONLY	DARKEN_ONLY_MODE
      LIGHTEN_ONLY	LIGHTEN_ONLY_MODE
      BEHIND		BEHIND_MODE
      COLOR		COLOR_MODE
      DISSOLVE		DISSOLVE_MODE
      HUE		HUE_MODE
      OVERLAY		OVERLAY_MODE
      SATURATION	SATURATION_MODE
      SCREEN		SCREEN_MODE
      SUBTRACT		SUBTRACT_MODE
      VALUE		VALUE_MODE

      ALPHA_MASK	ADD_ALPHA_MASK
      BLACK_MASK	ADD_BLACK_MASK
      WHITE_MASK	ADD_WHITE_MASK

      *pi*		3.14159265
   );
   my $constants = join("|",map {quotemeta} sort {length($b) <=> length($a)} keys %constant);
   my %compat_fun = (
cdr	=> 'sub cdr {
   my(@x)=@{$_[0]};
   shift(@x);
   @x >1 ? [@x] : $x[0];
}',

cddr	=> 'sub cddr {
   my(@x)=@{$_[0]};
   shift(@x); shift(@x);
   @x >1 ? [@x] : $x[0];
}',

cdddr	=> 'sub cdddr {
   my(@x)=@{$_[0]};
   shift(@x); shift(@x); shift(@x);
   @x >1 ? [@x] : $x[0];
}',

cddddr	=> 'sub cddddr {
   my(@x)=@{$_[0]};
   shift(@x); shift(@x);
   shift(@x); shift(@x); shift(@x);
   @x >1 ? [@x] : $x[0];
}',

max	=> 'sub max {
   $_[0] > $_[1] ? $_[0] : $_[1];
}',

min	=> 'sub min {
   $_[0] < $_[1] ? $_[0] : $_[1];
}',

fmod	=> 'sub fmod {
   $_[0] - int($_[0]/$_[1])*$_[1];
}',

'number->string' => 'sub number2string {
   sprintf "%$_[1]d",$_[0];
}',

nth	=> 'sub nth {
   $_[1]->[$_[0]];
}',

   );
   my $xskip;

   my $compat_fun = join("|",map {quotemeta} sort {length($b) <=> length($a)} keys %compat_fun);

   sub func2perl {
      my($name)=@_;
      $name=~s/->/2/g;
      $name=~y/-*<>?!:\//_/;
      $name=~/^[A-Za-z_]/ ? $name : "_$name";
   }

   sub sf2pf {
      my $name=lc $_[0];
      $name=~y/ -?!:<>\[]/__/d;
      $name=~s/_*[()].*$/"/;
      $name=~s/_\d*_/_/g;
      $name=~s/_+$//;
      sprintf "%-20s","'$name',";
   }
;


{
local $SIG{__WARN__} = sub {0};
# PRETEND TO BE IN Parse::RecDescent NAMESPACE
*Parse::RecDescent::ScmToPerl::Grammar::AUTOLOAD   = sub
{
    no strict 'refs';

    ${"AUTOLOAD"} =~ s/^Parse::RecDescent::ScmToPerl::Grammar/Parse::RecDescent/;
    goto &{${"AUTOLOAD"}};
}
}

push @Parse::RecDescent::ScmToPerl::Grammar::ISA, 'Parse::RecDescent';
# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_17_of_rule_cp_expr
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_17_of_rule_cp_expr"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_17_of_rule_cp_expr]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_17_of_rule_cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' gen expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_17_of_rule_cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_17_of_rule_cp_expr});
        %item = (__RULE__ => q{_alternation_1_of_production_17_of_rule_cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_17_of_rule_cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_17_of_rule_cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["."] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_17_of_rule_cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_17_of_rule_cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_17_of_rule_cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_17_of_rule_cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_17_of_rule_cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [')' gen expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_17_of_rule_cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_17_of_rule_cp_expr},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_17_of_rule_cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_17_of_rule_cp_expr},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_17_of_rule_cp_expr},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_19_of_rule_cp_expr
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_19_of_rule_cp_expr"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_19_of_rule_cp_expr]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_19_of_rule_cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{gen});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [gen expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_19_of_rule_cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_19_of_rule_cp_expr});
        %item = (__RULE__ => q{_alternation_1_of_production_19_of_rule_cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_19_of_rule_cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [","] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_19_of_rule_cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_19_of_rule_cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_19_of_rule_cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_19_of_rule_cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_19_of_rule_cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [gen expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_19_of_rule_cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_19_of_rule_cp_expr},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_19_of_rule_cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_19_of_rule_cp_expr},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_19_of_rule_cp_expr},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' gen pardef]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [", "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [pardef]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{pardef})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::pardef($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [pardef]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [pardef]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{pardef}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [')' gen pardef]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' gen expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [", "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [')' gen expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' gen expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [", "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [')' gen expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' gen expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [", "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [')' gen expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_c_defun
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_c_defun"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_c_defun]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' gen pardef ')' gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_c_defun});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_c_defun});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["my ("] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [pardef]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{pardef})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::pardef($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [pardef]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [pardef]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{pardef}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [')']},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{')'})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun, 0, 100000000, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [')']>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun(s?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [") = \@_;"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [')' gen pardef ')' gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_c_defun},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_c_defun},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_c_if
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_c_if"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_c_if]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'(', or ')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['(' ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_c_if});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_c_if});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: ['(' ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_c_if});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_c_if});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying repeated subrule: [')']},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if, 0, 1, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [')']>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if(?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{>>Matched production: [')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_c_if},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_c_let
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_c_let"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_c_let]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{expr});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_c_let});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_c_let});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_c_let},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [";"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_c_let},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_c_let},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_c_let},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_c_let},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_c_reg
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_c_reg"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_c_reg]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [<reject:$arg[0]!~/^.<Image>/> skip paramdef paramdef unskip]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_c_reg});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_c_reg});
        my $repcount = 0;


        

        Parse::RecDescent::_trace(q{Trying directive: [<reject:$arg[0]!~/^.<Image>/>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { ($arg[0]!~/^.<Image>/) ? undef : 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [skip]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{skip})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::skip($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [skip]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [skip]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{skip}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [paramdef]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{paramdef})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::paramdef($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [paramdef]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [paramdef]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{paramdef}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [paramdef]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{paramdef})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::paramdef($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [paramdef]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [paramdef]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{paramdef}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [unskip]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{unskip})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::unskip($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [unskip]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [unskip]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{unskip}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [<reject:$arg[0]!~/^.<Image>/> skip paramdef paramdef unskip]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_c_reg},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_c_reg},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_c_reg},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_cond
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_cond"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_cond]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/'?else\\b/, or expr});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/'?else\\b/ expr ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_cond});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_cond});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/'?else\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:'?else\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: [/'?else\\b/ expr ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [expr gen expr incindent nl gen ')' decindent '(', or gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_cond});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_cond});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [" ? "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [incindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{incindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::incindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [incindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [incindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{incindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [": "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [decindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{decindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::decindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [decindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [decindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{decindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{'(', or gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [expr gen expr incindent nl gen ')' decindent '(', or gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_cond},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_e_binop
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_e_binop"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_e_binop]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_e_binop},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' gen expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_e_binop},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_e_binop});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_e_binop});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_binop},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_e_binop},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [" $arg[0] "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_e_binop},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_binop},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_e_binop},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_e_binop},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_binop},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [')' gen expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_binop},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_e_binop},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_e_binop},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_e_binop},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_e_binop},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_e_call
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_e_call"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_e_call]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/script-fu-[A-Za-z_*][A-Za-z0-9-_*]*/, or ident});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/script-fu-[A-Za-z_*][A-Za-z0-9-_*]*/ gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_e_call});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_e_call});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/script-fu-[A-Za-z_*][A-Za-z0-9-_*]*/]}, Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:script-fu-[A-Za-z_*][A-Za-z0-9-_*]*)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\"$item[-1]\"->(RUN_NONINTERACTIVE, "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_e_call},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/script-fu-[A-Za-z_*][A-Za-z0-9-_*]*/ gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [ident gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_e_call});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_e_call});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [ident]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::ident($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [ident]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_e_call},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [ident]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{ident}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["$item[-1] ("] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_e_call},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [ident gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_e_call},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_e_call},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_e_call},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_e_list
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_e_list"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_e_list]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_e_list},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{expr});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [expr ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_e_list});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_e_list});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_e_list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_e_list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [')']},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_e_list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{')'})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list, 0, 100000000, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [')']>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_e_list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list(s?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{>>Matched production: [expr ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_e_list},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_e_list},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_gen
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_gen"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_gen]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_gen},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [<reject:$xskip> <defer:{  print ::OUT $arg[0]  }>]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_gen},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_gen});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_gen});
        my $repcount = 0;


        

        Parse::RecDescent::_trace(q{Trying directive: [<reject:$xskip>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_gen},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { ($xskip) ? undef : 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<defer:{  print ::OUT $arg[0]  }>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_gen},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { push @{$thisparser->{deferred}}, sub {  print ::OUT $arg[0]  }; };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE2__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Matched production: [<reject:$xskip> <defer:{  print ::OUT $arg[0]  }>]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_gen},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_gen},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_gen},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_gen},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_gen},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_list
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_list"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_list]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_list},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{expr});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [expr ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_list});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_list});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [')']},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{')'})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list, 0, 100000000, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [')']>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list(s?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{>>Matched production: [expr ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_list},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_list},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_list},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_paramdef
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_paramdef"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_paramdef]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'"TRUE"', or '"FALSE"', or expr});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['"TRUE"' gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_paramdef});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_paramdef});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['"TRUE"']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\"TRUE\"/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["1"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_paramdef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['"TRUE"' gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['"FALSE"' gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_paramdef});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_paramdef});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['"FALSE"']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\"FALSE\"/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["0"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_paramdef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['"FALSE"' gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[2];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_paramdef});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_paramdef});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_paramdef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_paramdef},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_paramdef},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_script
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_script"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_script]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_script},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/$/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/$/ stmt]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_script},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_script});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_script});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/$/]}, Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_script},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:$)/)
        {
            $text = $_savetext;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [stmt]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_script},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{stmt})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::stmt($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [stmt]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_script},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [stmt]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_script},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{stmt}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/$/ stmt]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_script},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_script},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_script},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_script},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_script},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_stmts
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_stmts"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_stmts]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_1_of_rule_stmts},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' nl stmt]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_1_of_rule_stmts},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_1_of_rule_stmts});
        %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_stmts});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_stmts},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_stmts},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_stmts},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_stmts},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [stmt]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_1_of_rule_stmts},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{stmt})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::stmt($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [stmt]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_1_of_rule_stmts},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [stmt]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_stmts},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{stmt}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [')' nl stmt]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_1_of_rule_stmts},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_1_of_rule_stmts},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_1_of_rule_stmts},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_1_of_rule_stmts},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_1_of_rule_stmts},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' gen incindent nl stmt decindent nl gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if});
        %item = (__RULE__ => q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [" else {"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [incindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{incindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::incindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [incindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [incindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{incindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [stmt]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{stmt})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::stmt($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [stmt]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [stmt]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{stmt}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [decindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{decindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::decindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [decindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [decindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{decindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["}"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [')' gen incindent nl stmt decindent nl gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'(', or gen});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['(' cond]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond});
        %item = (__RULE__ => q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [cond]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{cond})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::cond($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [cond]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [cond]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{cond}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['(' cond]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond});
        %item = (__RULE__ => q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["die 'cond fell off the end'"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_2_of_production_1_of_rule_c_reg
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_2_of_production_1_of_rule_c_reg"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_2_of_production_1_of_rule_c_reg]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_2_of_production_1_of_rule_c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' paramdef]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_2_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_2_of_production_1_of_rule_c_reg});
        %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_c_reg});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_2_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [paramdef]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_2_of_production_1_of_rule_c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{paramdef})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::paramdef($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [paramdef]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_2_of_production_1_of_rule_c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [paramdef]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_2_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{paramdef}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [')' paramdef]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_2_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_2_of_production_1_of_rule_c_reg},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_2_of_production_1_of_rule_c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_2_of_production_1_of_rule_c_reg},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_2_of_production_1_of_rule_c_reg},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::_alternation_2_of_production_1_of_rule_e_call
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"_alternation_2_of_production_1_of_rule_e_call"};

    Parse::RecDescent::_trace(q{Trying rule: [_alternation_2_of_production_1_of_rule_e_call]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{_alternation_2_of_production_1_of_rule_e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' expr ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{_alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{_alternation_2_of_production_1_of_rule_e_call});
        %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_e_call});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_2_of_production_1_of_rule_e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_2_of_production_1_of_rule_e_call},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [')']},
                  Parse::RecDescent::_tracefirst($text),
                  q{_alternation_2_of_production_1_of_rule_e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{')'})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call, 0, 100000000, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [')']>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{_alternation_2_of_production_1_of_rule_e_call},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call(s?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{>>Matched production: [')' expr ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{_alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{_alternation_2_of_production_1_of_rule_e_call},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{_alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{_alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{_alternation_2_of_production_1_of_rule_e_call},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::atom
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"atom"};

    Parse::RecDescent::_trace(q{Trying rule: [atom]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{atom},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{constant, or 'gimp-data-dir', or ident, or numeral, or string, or list, or ''not-guile'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [constant]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{atom});
        %item = (__RULE__ => q{atom});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [constant]},
                  Parse::RecDescent::_tracefirst($text),
                  q{atom},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::constant($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [constant]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{atom},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [constant]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{constant}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [constant]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['gimp-data-dir' gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{atom});
        %item = (__RULE__ => q{atom});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['gimp-data-dir']},
                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Agimp\-data\-dir/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{atom},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["'/usr/local/share/gimp'"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{atom},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['gimp-data-dir' gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [ident gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[2];
        $text = $_[1];
        my $_savetext;
        @item = (q{atom});
        %item = (__RULE__ => q{atom});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [ident]},
                  Parse::RecDescent::_tracefirst($text),
                  q{atom},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::ident($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [ident]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{atom},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [ident]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{ident}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{atom},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\$$item[-1]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{atom},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [ident gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [numeral]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[3];
        $text = $_[1];
        my $_savetext;
        @item = (q{atom});
        %item = (__RULE__ => q{atom});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [numeral]},
                  Parse::RecDescent::_tracefirst($text),
                  q{atom},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::numeral($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [numeral]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{atom},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [numeral]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{numeral}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [numeral]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [string gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[4];
        $text = $_[1];
        my $_savetext;
        @item = (q{atom});
        %item = (__RULE__ => q{atom});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [string]},
                  Parse::RecDescent::_tracefirst($text),
                  q{atom},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::string($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [string]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{atom},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [string]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{string}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{atom},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$item[-1]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{atom},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [string gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [list]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[5];
        $text = $_[1];
        my $_savetext;
        @item = (q{atom});
        %item = (__RULE__ => q{atom});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [list]},
                  Parse::RecDescent::_tracefirst($text),
                  q{atom},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::list($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [list]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{atom},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [list]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{list}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [list]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [''not-guile' gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[6];
        $text = $_[1];
        my $_savetext;
        @item = (q{atom});
        %item = (__RULE__ => q{atom});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [''not-guile']},
                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   do { $_tok = "'not-guile"; 1 } and
             substr($text,0,length($_tok)) eq $_tok and
             do { substr($text,0,length($_tok)) = ""; 1; }
        )
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $_tok . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{atom},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["1"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{atom},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [''not-guile' gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{atom},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{atom},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{atom},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{atom},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::c_aset
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"c_aset"};

    Parse::RecDescent::_trace(q{Trying rule: [c_aset]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{c_aset},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/aset\\b/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/aset\\b/ <commit> ident gen expr gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{c_aset},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{c_aset});
        %item = (__RULE__ => q{c_aset});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/aset\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{c_aset},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:aset\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<commit>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{c_aset},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { $commit = 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [ident]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_aset},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{ident})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::ident($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [ident]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_aset},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [ident]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_aset},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{ident}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_aset},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\$$item[-1]\->["] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_aset},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_aset},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_aset},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_aset},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_aset},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_aset},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["] = "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_aset},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_aset},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_aset},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_aset},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_aset},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_aset},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [";"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_aset},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_aset},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/aset\\b/ <commit> ident gen expr gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_aset},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{c_aset},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{c_aset},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{c_aset},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{c_aset},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::c_define
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"c_define"};

    Parse::RecDescent::_trace(q{Trying rule: [c_define]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{c_define},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'define'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['define' ident gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{c_define},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{c_define});
        %item = (__RULE__ => q{c_define});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['define']},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_define},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Adefine/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [ident]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_define},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{ident})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::ident($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [ident]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_define},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [ident]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_define},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{ident}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_define},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\$$item[-1] = "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_define},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_define},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_define},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_define},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_define},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_define},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [";"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_define},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_define},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['define' ident gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_define},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{c_define},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{c_define},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{c_define},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{c_define},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::c_defun
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"c_defun"};

    Parse::RecDescent::_trace(q{Trying rule: [c_defun]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'define'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['define' '(' <commit> ident nl gen incindent nl ')' ')' stmts decindent nl gen nl]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{c_defun});
        %item = (__RULE__ => q{c_defun});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['define']},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Adefine/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{'('})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<commit>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { $commit = 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [ident]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{ident})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::ident($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [ident]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [ident]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{ident}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["sub $item[-2] {"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [incindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{incindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::incindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [incindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [incindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{incindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [')']},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{')'})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_c_defun, 0, 1, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [')']>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_c_defun]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_c_defun(?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING3__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [stmts]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{stmts})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::stmts($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [stmts]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [stmts]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{stmts}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [decindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{decindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::decindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [decindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [decindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{decindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["}"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_defun},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_defun},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['define' '(' <commit> ident nl gen incindent nl ')' ')' stmts decindent nl gen nl]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{c_defun},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{c_defun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{c_defun},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{c_defun},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::c_if
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"c_if"};

    Parse::RecDescent::_trace(q{Trying rule: [c_if]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'if'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['if' <commit> gen expr gen incindent nl stmt decindent nl gen '(', or ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{c_if});
        %item = (__RULE__ => q{c_if});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['if']},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Aif/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<commit>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { $commit = 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["if ("] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [") {"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [incindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{incindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::incindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [incindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [incindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{incindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [stmt]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{stmt})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::stmt($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [stmt]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [stmt]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{stmt}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [decindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{decindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::decindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [decindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [decindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{decindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["}"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_c_if]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{'(', or ')'})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_c_if($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_c_if]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_c_if]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_c_if}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['if' <commit> gen expr gen incindent nl stmt decindent nl gen '(', or ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{c_if},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{c_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{c_if},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{c_if},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::c_let
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"c_let"};

    Parse::RecDescent::_trace(q{Trying rule: [c_let]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/let(\\*|rec)?/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/let(\\*|rec)?/ <commit> gen incindent '(' let_expr ')' nl stmts expr decindent nl gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{c_let});
        %item = (__RULE__ => q{c_let});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/let(\\*|rec)?/]}, Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:let(\*|rec)?)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<commit>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { $commit = 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["do {"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_let},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [incindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{incindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::incindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [incindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_let},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [incindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{incindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{'('})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying repeated subrule: [let_expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{let_expr})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::let_expr, 1, 100000000, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [let_expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_let},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [let_expr]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{let_expr(s)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_let},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [stmts]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{stmts})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::stmts($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [stmts]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_let},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [stmts]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{stmts}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{expr})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_c_let, 0, 1, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_let},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_c_let]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_c_let(?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{Trying subrule: [decindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{decindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::decindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [decindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_let},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [decindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{decindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_let},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_let},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["};"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_let},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/let(\\*|rec)?/ <commit> gen incindent '(' let_expr ')' nl stmts expr decindent nl gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{c_let},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{c_let},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{c_let},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{c_let},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::c_reg
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"c_reg"};

    Parse::RecDescent::_trace(q{Trying rule: [c_reg]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'script-fu-register'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['script-fu-register' <commit> string string string string string string string nl gen incindent gen gen nl gen gen nl gen gen nl gen gen nl gen gen nl gen gen nl gen gen nl gen gen nl gen incindent _alternation_1_of_production_1_of_rule_c_reg ')' decindent nl gen nl gen decindent]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{c_reg});
        %item = (__RULE__ => q{c_reg});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['script-fu-register']},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Ascript\-fu\-register/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<commit>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { $commit = 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [string]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{string})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::string($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [string]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [string]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{string}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [string]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{string})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::string($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [string]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [string]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{string}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [string]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{string})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::string($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [string]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [string]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{string}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [string]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{string})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::string($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [string]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [string]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{string}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [string]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{string})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::string($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [string]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [string]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{string}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [string]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{string})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::string($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [string]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [string]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{string}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [string]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{string})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::string($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [string]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [string]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{string}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying action},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        

        $_tok = ($_noactions) ? 0 : do {
	    $item[1]=func2perl(substr($item[3],1,length($item[3])-2));
	    $item[3]=~s/script-fu/perl_fu/;
	    $item[3]=~y/-/_/;
	    $item[4]=~s/Script-Fu/Perl-Fu/;
	    $item[5]=~s/\s{2,}/ /g;
	  };
        unless (defined $_tok)
        {
            Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
                    if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
                      . $_tok . q{])},
                      Parse::RecDescent::_tracefirst($text))
                        if defined $::RD_TRACE;
        push @item, $_tok;
        $item{__ACTION1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["register "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [incindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{incindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::incindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [incindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [incindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{incindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$item[3]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [","] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$item[5]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [","] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$item[5]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [","] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$item[6]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [","] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$item[7]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [","] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$item[8]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [","] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$item[4]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [","] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$item[9]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [","] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["["] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [incindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{incindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::incindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [incindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [incindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{incindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [_alternation_1_of_production_1_of_rule_c_reg]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{_alternation_1_of_production_1_of_rule_c_reg})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_c_reg, 0, 1, $_noactions,$expectation,sub { return [$item[4]] },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [_alternation_1_of_production_1_of_rule_c_reg]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_c_reg]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_c_reg(?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{Trying repeated subrule: [')']},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{')'})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_2_of_production_1_of_rule_c_reg, 0, 100000000, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [')']>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_2_of_production_1_of_rule_c_reg]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_2_of_production_1_of_rule_c_reg(s?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{Trying subrule: [decindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{decindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::decindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [decindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [decindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{decindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["],"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\\&$item[1];"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [decindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_reg},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{decindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::decindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [decindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_reg},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [decindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{decindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['script-fu-register' <commit> string string string string string string string nl gen incindent gen gen nl gen gen nl gen gen nl gen gen nl gen gen nl gen gen nl gen gen nl gen gen nl gen incindent _alternation_1_of_production_1_of_rule_c_reg ')' decindent nl gen nl gen decindent]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{c_reg},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{c_reg},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{c_reg},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{c_reg},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::c_set
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"c_set"};

    Parse::RecDescent::_trace(q{Trying rule: [c_set]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{c_set},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/set!?/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/set!?/ <commit> ident gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{c_set},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{c_set});
        %item = (__RULE__ => q{c_set});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/set!?/]}, Parse::RecDescent::_tracefirst($text),
                      q{c_set},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:set!?)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<commit>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{c_set},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { $commit = 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [ident]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_set},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{ident})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::ident($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [ident]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_set},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [ident]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_set},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{ident}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_set},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\$$item[-1] = "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_set},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_set},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_set},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_set},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_set},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_set},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [";"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_set},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_set},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/set!?/ <commit> ident gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_set},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{c_set},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{c_set},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{c_set},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{c_set},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::c_while
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"c_while"};

    Parse::RecDescent::_trace(q{Trying rule: [c_while]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{c_while},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'while'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['while' <commit> nl gen expr gen incindent stmts decindent nl gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{c_while});
        %item = (__RULE__ => q{c_while});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['while']},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Awhile/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<commit>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { $commit = 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_while},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_while},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_while},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["while ("] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_while},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_while},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_while},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_while},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [") {"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_while},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [incindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_while},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{incindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::incindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [incindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_while},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [incindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{incindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [stmts]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_while},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{stmts})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::stmts($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [stmts]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_while},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [stmts]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{stmts}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [decindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_while},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{decindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::decindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [decindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_while},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [decindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{decindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_while},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_while},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{c_while},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["}"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{c_while},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['while' <commit> nl gen expr gen incindent stmts decindent nl gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{c_while},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{c_while},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{c_while},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{c_while},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::command
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"command"};

    Parse::RecDescent::_trace(q{Trying rule: [command]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{cp_expr, or c_let, or c_set, or c_if, or c_while, or e_cond, or c_aset, or c_defun, or c_define, or c_reg, or /print\\b/, or e_call, or atom});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [cp_expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [cp_expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::cp_expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [cp_expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [cp_expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{cp_expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [";"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [cp_expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [c_let]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [c_let]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::c_let($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [c_let]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [c_let]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{c_let}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [c_let]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [c_set]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[2];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [c_set]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::c_set($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [c_set]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [c_set]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{c_set}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [c_set]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [c_if]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[3];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [c_if]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::c_if($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [c_if]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [c_if]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{c_if}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [c_if]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [c_while]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[4];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [c_while]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::c_while($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [c_while]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [c_while]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{c_while}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [c_while]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [e_cond gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[5];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [e_cond]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_cond($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_cond]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_cond]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_cond}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [";"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [e_cond gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [c_aset]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[6];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [c_aset]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::c_aset($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [c_aset]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [c_aset]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{c_aset}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [c_aset]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [c_defun]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[7];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [c_defun]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::c_defun($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [c_defun]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [c_defun]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{c_defun}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [c_defun]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [c_define]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[8];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [c_define]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::c_define($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [c_define]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [c_define]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{c_define}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [c_define]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [c_reg]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[9];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [c_reg]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::c_reg($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [c_reg]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [c_reg]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{c_reg}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [c_reg]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/print\\b/ gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[10];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/print\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:print\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["print "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [",'\n';"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/print\\b/ gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [e_call gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[11];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [e_call]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_call($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_call]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_call]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_call}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [";"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [e_call gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [atom gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[12];
        $text = $_[1];
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [atom]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::atom($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [atom]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [atom]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{atom}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{command},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [";"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{command},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [atom gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [<error...>]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[13];
        
        my $_savetext;
        @item = (q{command});
        %item = (__RULE__ => q{command});
        my $repcount = 0;


        

        Parse::RecDescent::_trace(q{Trying directive: [<error...>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { if (1) { do {push @{$thisparser->{errors}}, [qq{unrecognized statement},$thisline];} unless  $_noactions; undef } else {0} };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Matched production: [<error...>]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{command},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{command},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{command},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{command},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::cond
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"cond"};

    Parse::RecDescent::_trace(q{Trying rule: [cond]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{cond},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'('});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['(' /'?else\\b/, or expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{cond});
        %item = (__RULE__ => q{cond});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_cond]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{/'?else\\b/, or expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_cond($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_cond]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_cond]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_cond}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['(' /'?else\\b/, or expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cond},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{cond},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{cond},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{cond},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::constant
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"constant"};

    Parse::RecDescent::_trace(q{Trying rule: [constant]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{constant},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/(?:$constants)(?=[ \\t;)\\n\\r])/, or /[A-Z-_]\{3,\}/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/(?:$constants)(?=[ \\t;)\\n\\r])/ gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{constant},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{constant});
        %item = (__RULE__ => q{constant});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/(?:$constants)(?=[ \\t;)\\n\\r])/]}, Parse::RecDescent::_tracefirst($text),
                      q{constant},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:(?:$constants)(?=[ \t;)\n\r]))/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{constant},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$constant{$item[-1]}] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{constant},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{constant},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/(?:$constants)(?=[ \\t;)\\n\\r])/ gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{constant},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/[A-Z-_]\{3,\}/ gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{constant},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{constant});
        %item = (__RULE__ => q{constant});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/[A-Z-_]\{3,\}/]}, Parse::RecDescent::_tracefirst($text),
                      q{constant},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:[A-Z-_]{3,})/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{constant},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [func2perl($item[-1])] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{constant},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{constant},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/[A-Z-_]\{3,\}/ gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{constant},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{constant},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{constant},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{constant},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{constant},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::cp_expr
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"cp_expr"};

    Parse::RecDescent::_trace(q{Trying rule: [cp_expr]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/car\\b/, or e_begin, or e_list, or '=', or '-', or m\{[-+]|and\\b\}, or m\{<=|>=|!=|[*/<>]|or\\b\}, or /eq\\?|eqv\\?|equal\\?/, or /realtime\\b/, or /modulo\\b/, or 'divide?', or 'string-append', or 'number->string', or 'cons-array', or 'symbol-bound?', or /aref\\b/, or /$compat_fun/, or /cadr\\b/, or /caddr\\b/, or /cadddr\\b/, or 'null?', or /cons\\b/, or ')', or '(', or constant});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/car\\b/ '(' pdbfun e_call ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/car\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:car\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{'('})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [pdbfun]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{pdbfun})->at($text);
        $_savetext = $text;unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::pdbfun($thisparser,$text,$repeating,1,sub { \@arg },undef)))
        {
            $text = $_savetext;
            Parse::RecDescent::_trace(q{<<...Didn't match(reject) subrule: [pdbfun]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>...Matched(keep) subrule: [pdbfun]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{pdbfun}} = $_tok;
        push @item, $_tok;
        $text = $_savetext;
        }

        Parse::RecDescent::_trace(q{Trying subrule: [e_call]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{e_call})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_call($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_call]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_call]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_call}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: [/car\\b/ '(' pdbfun e_call ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [e_begin]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [e_begin]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_begin($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_begin]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_begin]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_begin}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [e_begin]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [e_list]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[2];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [e_list]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_list($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_list]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_list]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_list}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [e_list]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['=' expr 'TRUE']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[3];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['=']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\=/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: ['TRUE']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{'TRUE'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\ATRUE/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: ['=' expr 'TRUE']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['=' 'TRUE' expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[4];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['=']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\=/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying terminal: ['TRUE']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{'TRUE'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\ATRUE/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['=' 'TRUE' expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['=' gen expr 'FALSE']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[5];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['=']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\=/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["!"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: ['FALSE']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{'FALSE'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\AFALSE/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: ['=' gen expr 'FALSE']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['=' gen 'FALSE' expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[6];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['=']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\=/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["!"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: ['FALSE']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{'FALSE'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\AFALSE/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['=' gen 'FALSE' expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['-' gen expr ')' gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[7];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['-']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\-/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["-("] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        $_savetext = $text;

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [")"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['-' gen expr ')' gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [m\{[-+]|and\\b\} gen e_binop gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[8];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [m\{[-+]|and\\b\}]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m{\A(?:[-+]|and\b)})
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["("] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [e_binop]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{e_binop})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_binop($thisparser,$text,$repeating,$_noactions,sub { return [$item[1]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_binop]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_binop]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_binop}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [")"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [m\{[-+]|and\\b\} gen e_binop gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [m\{<=|>=|!=|[*/<>]|or\\b\} e_binop]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[9];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [m\{<=|>=|!=|[*/<>]|or\\b\}]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m{\A(?:<=|>=|!=|[*/<>]|or\b)})
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [e_binop]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{e_binop})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_binop($thisparser,$text,$repeating,$_noactions,sub { return [$item[1]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_binop]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_binop]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_binop}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [m\{<=|>=|!=|[*/<>]|or\\b\} e_binop]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['=' e_binop]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[10];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['=']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\=/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [e_binop]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{e_binop})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_binop($thisparser,$text,$repeating,$_noactions,sub { return ["=="] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_binop]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_binop]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_binop}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['=' e_binop]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/eq\\?|eqv\\?|equal\\?/ '()' expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[11];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/eq\\?|eqv\\?|equal\\?/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:eq\?|eqv\?|equal\?)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying terminal: ['()']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{'()'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [" eq ''"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/eq\\?|eqv\\?|equal\\?/ '()' expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/eq\\?|eqv\\?|equal\\?/ e_binop]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[12];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/eq\\?|eqv\\?|equal\\?/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:eq\?|eqv\?|equal\?)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [e_binop]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{e_binop})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_binop($thisparser,$text,$repeating,$_noactions,sub { return ["eq"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_binop]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_binop]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_binop}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/eq\\?|eqv\\?|equal\\?/ e_binop]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/realtime\\b/ gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[13];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/realtime\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:realtime\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["time"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/realtime\\b/ gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/modulo\\b/ expr gen expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[14];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/modulo\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:modulo\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [" % "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/modulo\\b/ expr gen expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['divide?' gen expr gen expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[15];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['divide?']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Adivide\?/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["!"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["%"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['divide?' gen expr gen expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['string-append' expr ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[16];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['string-append']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Astring\-append/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [')']},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{')'})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_17_of_rule_cp_expr, 0, 100000000, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [')']>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_17_of_rule_cp_expr]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_17_of_rule_cp_expr(s?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{>>Matched production: ['string-append' expr ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['number->string' expr ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[17];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['number->string']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Anumber\-\>string/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        $_savetext = $text;

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{>>Matched production: ['number->string' expr ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['cons-array' gen expr gen gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[18];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['cons-array']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Acons\-array/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["("] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{gen})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_19_of_rule_cp_expr, 0, 1, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_19_of_rule_cp_expr]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_19_of_rule_cp_expr(?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [",[])"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['cons-array' gen expr gen gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['symbol-bound?' string '(' ident ')' gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[19];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['symbol-bound?']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Asymbol\-bound\?/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [string]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{string})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::string($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [string]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [string]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{string}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{'('})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [ident]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{ident})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::ident($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [ident]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [ident]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{ident}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING3__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["0"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['symbol-bound?' string '(' ident ')' gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/aref\\b/ expr gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[20];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/aref\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:aref\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["->["] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/aref\\b/ expr gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/$compat_fun/ <reject>]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[21];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/$compat_fun/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:$compat_fun)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying action},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        

        $_tok = ($_noactions) ? 0 : do { $::add_funcs{$compat_fun{$item[1]}}++ };
        unless (defined $_tok)
        {
            Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
                    if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
                      . $_tok . q{])},
                      Parse::RecDescent::_tracefirst($text))
                        if defined $::RD_TRACE;
        push @item, $_tok;
        $item{__ACTION1__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Rejecting production<< (found <reject>)},
                     Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $return;
        

        $_tok = undef;
        
        last unless defined $_tok;

        Parse::RecDescent::_trace(q{>>Matched production: [/$compat_fun/ <reject>]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/car\\b/ gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[22];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/car\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:car\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\@{"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["}[0]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/car\\b/ gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/cadr\\b/ gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[23];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/cadr\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:cadr\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\@{"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["}[1]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/cadr\\b/ gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/caddr\\b/ gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[24];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/caddr\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:caddr\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\@{"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["}[2]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/caddr\\b/ gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/cadddr\\b/ gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[25];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/cadddr\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:cadddr\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\@{"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["}[3]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/cadddr\\b/ gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['null?' gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[26];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['null?']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Anull\?/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["!\@{"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["}"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['null?' gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/cons\\b/ gen expr gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[27];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/cons\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:cons\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["["] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [", "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/cons\\b/ gen expr gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[28];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["[]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [')' gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['(' cp_expr ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[29];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [cp_expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{cp_expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::cp_expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [cp_expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [cp_expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{cp_expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: ['(' cp_expr ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [constant]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[30];
        $text = $_[1];
        my $_savetext;
        @item = (q{cp_expr});
        %item = (__RULE__ => q{cp_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [constant]},
                  Parse::RecDescent::_tracefirst($text),
                  q{cp_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::constant($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [constant]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{cp_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [constant]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{constant}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [constant]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{cp_expr},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{cp_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{cp_expr},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{cp_expr},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::decindent
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"decindent"};

    Parse::RecDescent::_trace(q{Trying rule: [decindent]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{decindent},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: []},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{decindent},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{decindent});
        %item = (__RULE__ => q{decindent});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying action},
                      Parse::RecDescent::_tracefirst($text),
                      q{decindent},
                      $tracelevel)
                        if defined $::RD_TRACE;
        

        $_tok = ($_noactions) ? 0 : do { $indent-- };
        unless (defined $_tok)
        {
            Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
                    if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
                      . $_tok . q{])},
                      Parse::RecDescent::_tracefirst($text))
                        if defined $::RD_TRACE;
        push @item, $_tok;
        $item{__ACTION1__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Matched production: []<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{decindent},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{decindent},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{decindent},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{decindent},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{decindent},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::e_begin
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"e_begin"};

    Parse::RecDescent::_trace(q{Trying rule: [e_begin]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{e_begin},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/begin\\b|prog1\\b/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/begin\\b|prog1\\b/ <commit> gen incindent stmts decindent nl gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{e_begin},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{e_begin});
        %item = (__RULE__ => q{e_begin});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/begin\\b|prog1\\b/]}, Parse::RecDescent::_tracefirst($text),
                      q{e_begin},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:begin\b|prog1\b)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<commit>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{e_begin},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { $commit = 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_begin},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["do {"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_begin},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_begin},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [incindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_begin},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{incindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::incindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [incindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_begin},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [incindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_begin},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{incindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [stmts]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_begin},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{stmts})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::stmts($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [stmts]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_begin},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [stmts]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_begin},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{stmts}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [decindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_begin},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{decindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::decindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [decindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_begin},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [decindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_begin},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{decindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_begin},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_begin},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_begin},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_begin},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["}"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_begin},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_begin},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/begin\\b|prog1\\b/ <commit> gen incindent stmts decindent nl gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{e_begin},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{e_begin},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{e_begin},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{e_begin},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{e_begin},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::e_binop
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"e_binop"};

    Parse::RecDescent::_trace(q{Trying rule: [e_binop]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{e_binop},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{expr});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [expr ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{e_binop},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{e_binop});
        %item = (__RULE__ => q{e_binop});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_binop},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_binop},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_binop},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [')']},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_binop},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{')'})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_e_binop, 0, 100000000, $_noactions,$expectation,sub { return [@arg] },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [')']>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_binop},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_e_binop]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_binop},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_e_binop(s?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{>>Matched production: [expr ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{e_binop},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{e_binop},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{e_binop},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{e_binop},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{e_binop},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::e_call
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"e_call"};

    Parse::RecDescent::_trace(q{Trying rule: [e_call]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/script-fu-[A-Za-z_*][A-Za-z0-9-_*]*/, or ident});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/script-fu-[A-Za-z_*][A-Za-z0-9-_*]*/, or ident ')' gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{e_call});
        %item = (__RULE__ => q{e_call});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_e_call]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_e_call($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_e_call]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_call},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_e_call]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_e_call}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [')']},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{')'})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_2_of_production_1_of_rule_e_call, 0, 1, $_noactions,$expectation,sub { return [@arg] },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [')']>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_call},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_2_of_production_1_of_rule_e_call]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_2_of_production_1_of_rule_e_call(?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_call},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [")"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_call},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/script-fu-[A-Za-z_*][A-Za-z0-9-_*]*/, or ident ')' gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{e_call},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{e_call},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{e_call},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{e_call},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::e_cond
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"e_cond"};

    Parse::RecDescent::_trace(q{Trying rule: [e_cond]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{e_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'cond'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['cond' <commit> cond]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{e_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{e_cond});
        %item = (__RULE__ => q{e_cond});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['cond']},
                      Parse::RecDescent::_tracefirst($text),
                      q{e_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Acond/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<commit>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{e_cond},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { $commit = 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [cond]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_cond},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{cond})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::cond($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [cond]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_cond},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [cond]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{cond}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['cond' <commit> cond]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{e_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{e_cond},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{e_cond},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{e_cond},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{e_cond},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::e_dot
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"e_dot"};

    Parse::RecDescent::_trace(q{Trying rule: [e_dot]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{e_dot},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'string-append'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['string-append' expr gen expr]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{e_dot},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{e_dot});
        %item = (__RULE__ => q{e_dot});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['string-append']},
                      Parse::RecDescent::_tracefirst($text),
                      q{e_dot},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Astring\-append/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_dot},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_dot},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_dot},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_dot},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["."] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_dot},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_dot},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_dot},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_dot},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_dot},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['string-append' expr gen expr]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{e_dot},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{e_dot},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{e_dot},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{e_dot},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{e_dot},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::e_if
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"e_if"};

    Parse::RecDescent::_trace(q{Trying rule: [e_if]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{e_if},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'if'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['if' <commit> gen expr gen expr gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{e_if});
        %item = (__RULE__ => q{e_if});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['if']},
                      Parse::RecDescent::_tracefirst($text),
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Aif/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<commit>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { $commit = 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["("] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [") ? ("] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [") : ("] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_if},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [")"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_if},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['if' <commit> gen expr gen expr gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{e_if},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{e_if},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{e_if},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{e_if},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::e_list
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"e_list"};

    Parse::RecDescent::_trace(q{Trying rule: [e_list]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{e_list},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'list'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['list' gen expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{e_list});
        %item = (__RULE__ => q{e_list});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['list']},
                      Parse::RecDescent::_tracefirst($text),
                      q{e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\Alist/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["["] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{expr})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_e_list, 0, 1, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_e_list]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_e_list(?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{e_list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{e_list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: ['list' gen expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{e_list},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{e_list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{e_list},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{e_list},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::expr
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"expr"};

    Parse::RecDescent::_trace(q{Trying rule: [expr]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'(', or atom, or ')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['(' e_if ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{expr});
        %item = (__RULE__ => q{expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [e_if]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{e_if})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_if($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_if]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_if]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_if}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: ['(' e_if ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['(' gen e_cond gen ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{expr});
        %item = (__RULE__ => q{expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["("] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [e_cond]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{e_cond})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_cond($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_cond]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_cond]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_cond}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [")"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: ['(' gen e_cond gen ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['(' cp_expr ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[2];
        $text = $_[1];
        my $_savetext;
        @item = (q{expr});
        %item = (__RULE__ => q{expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [cp_expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{cp_expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::cp_expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [cp_expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [cp_expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{cp_expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: ['(' cp_expr ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['(' pdbfun e_call ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[3];
        $text = $_[1];
        my $_savetext;
        @item = (q{expr});
        %item = (__RULE__ => q{expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [pdbfun]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{pdbfun})->at($text);
        $_savetext = $text;if (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::pdbfun($thisparser,$text,$repeating,1,sub { \@arg },undef)))
        {
            $text = $_savetext;
            Parse::RecDescent::_trace(q{<<...!Matched(reject) subrule: [pdbfun]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>...!Didn't match(keep) subrule: [pdbfun]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{pdbfun}} = $_tok;
        push @item, $_tok;
        $text = $_savetext;
        }

        Parse::RecDescent::_trace(q{Trying subrule: [e_call]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{e_call})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_call($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_call]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_call]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_call}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: ['(' pdbfun e_call ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['(' pdbfun gen e_call gen ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[4];
        $text = $_[1];
        my $_savetext;
        @item = (q{expr});
        %item = (__RULE__ => q{expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [pdbfun]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{pdbfun})->at($text);
        $_savetext = $text;unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::pdbfun($thisparser,$text,$repeating,1,sub { \@arg },undef)))
        {
            $text = $_savetext;
            Parse::RecDescent::_trace(q{<<...Didn't match(reject) subrule: [pdbfun]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>...Matched(keep) subrule: [pdbfun]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{pdbfun}} = $_tok;
        push @item, $_tok;
        $text = $_savetext;
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["["] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [e_call]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{e_call})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::e_call($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [e_call]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [e_call]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{e_call}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: ['(' pdbfun gen e_call gen ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['(' gen incindent nl command decindent nl gen ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[5];
        $text = $_[1];
        my $_savetext;
        @item = (q{expr});
        %item = (__RULE__ => q{expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["do {"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [incindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{incindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::incindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [incindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [incindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{incindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [command]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{command})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::command($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [command]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [command]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{command}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [decindent]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{decindent})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::decindent($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [decindent]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [decindent]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{decindent}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["}"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: ['(' gen incindent nl command decindent nl gen ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [atom]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[6];
        $text = $_[1];
        my $_savetext;
        @item = (q{expr});
        %item = (__RULE__ => q{expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [atom]},
                  Parse::RecDescent::_tracefirst($text),
                  q{expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::atom($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [atom]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [atom]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{atom}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [atom]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' <error...>]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[7];
        $text = $_[1];
        my $_savetext;
        @item = (q{expr});
        %item = (__RULE__ => q{expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        

        Parse::RecDescent::_trace(q{Trying directive: [<error...>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { if (1) { do {push @{$thisparser->{errors}}, [qq{unrecognized expression},$thisline];} unless  $_noactions; undef } else {0} };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Matched production: [')' <error...>]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{expr},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{expr},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{expr},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::gen
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"gen"};

    Parse::RecDescent::_trace(q{Trying rule: [gen]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{gen},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{_alternation_1_of_production_1_of_rule_gen});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [_alternation_1_of_production_1_of_rule_gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{gen},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{gen});
        %item = (__RULE__ => q{gen});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying repeated subrule: [_alternation_1_of_production_1_of_rule_gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{gen},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_gen, 0, 1, $_noactions,$expectation,sub { return [@arg] },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [_alternation_1_of_production_1_of_rule_gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{gen},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_gen]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{gen},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_gen(?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{>>Matched production: [_alternation_1_of_production_1_of_rule_gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{gen},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{gen},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{gen},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{gen},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{gen},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::ident
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"ident"};

    Parse::RecDescent::_trace(q{Trying rule: [ident]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{ident},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/[A-Za-z0-9-#_*!?<>=\\/]+/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/[A-Za-z0-9-#_*!?<>=\\/]+/ <reject:$item[1]!~/[A-Za-z]/>]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{ident},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{ident});
        %item = (__RULE__ => q{ident});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/[A-Za-z0-9-#_*!?<>=\\/]+/]}, Parse::RecDescent::_tracefirst($text),
                      q{ident},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:[A-Za-z0-9-#_*!?<>=\/]+)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        

        Parse::RecDescent::_trace(q{Trying directive: [<reject:$item[1]!~/[A-Za-z]/>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{ident},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { ($item[1]!~/[A-Za-z]/) ? undef : 1 };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying action},
                      Parse::RecDescent::_tracefirst($text),
                      q{ident},
                      $tracelevel)
                        if defined $::RD_TRACE;
        

        $_tok = ($_noactions) ? 0 : do { func2perl($item[1]) };
        unless (defined $_tok)
        {
            Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
                    if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
                      . $_tok . q{])},
                      Parse::RecDescent::_tracefirst($text))
                        if defined $::RD_TRACE;
        push @item, $_tok;
        $item{__ACTION1__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Matched production: [/[A-Za-z0-9-#_*!?<>=\\/]+/ <reject:$item[1]!~/[A-Za-z]/>]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{ident},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{ident},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{ident},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{ident},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{ident},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::incindent
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"incindent"};

    Parse::RecDescent::_trace(q{Trying rule: [incindent]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{incindent},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: []},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{incindent},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{incindent});
        %item = (__RULE__ => q{incindent});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying action},
                      Parse::RecDescent::_tracefirst($text),
                      q{incindent},
                      $tracelevel)
                        if defined $::RD_TRACE;
        

        $_tok = ($_noactions) ? 0 : do { printf STDERR " %2d%%\b\b\b\b",$thisoffset*100/$::filesize unless $::quiet };
        unless (defined $_tok)
        {
            Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
                    if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
                      . $_tok . q{])},
                      Parse::RecDescent::_tracefirst($text))
                        if defined $::RD_TRACE;
        push @item, $_tok;
        $item{__ACTION1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying action},
                      Parse::RecDescent::_tracefirst($text),
                      q{incindent},
                      $tracelevel)
                        if defined $::RD_TRACE;
        

        $_tok = ($_noactions) ? 0 : do { $indent++ };
        unless (defined $_tok)
        {
            Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
                    if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
                      . $_tok . q{])},
                      Parse::RecDescent::_tracefirst($text))
                        if defined $::RD_TRACE;
        push @item, $_tok;
        $item{__ACTION2__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Matched production: []<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{incindent},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{incindent},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{incindent},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{incindent},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{incindent},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::let_expr
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"let_expr"};

    Parse::RecDescent::_trace(q{Trying rule: [let_expr]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{let_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')' nl '(' ident gen expr gen ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{let_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{let_expr});
        %item = (__RULE__ => q{let_expr});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{let_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        $_savetext = $text;

        if ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $_savetext;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        $text = $_savetext;

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{let_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{let_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{let_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{let_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{'('})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [ident]},
                  Parse::RecDescent::_tracefirst($text),
                  q{let_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{ident})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::ident($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [ident]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{let_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [ident]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{let_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{ident}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{let_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["my \$$item[-1] = "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{let_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{let_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{let_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{let_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{let_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{let_expr},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [";"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{let_expr},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{let_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{let_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING3__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: [')' nl '(' ident gen expr gen ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{let_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{let_expr},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{let_expr},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{let_expr},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{let_expr},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::list
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"list"};

    Parse::RecDescent::_trace(q{Trying rule: [list]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{list},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{''('});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [''(' gen expr gen ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{list});
        %item = (__RULE__ => q{list});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [''(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   do { $_tok = "'("; 1 } and
             substr($text,0,length($_tok)) eq $_tok and
             do { substr($text,0,length($_tok)) = ""; 1; }
        )
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $_tok . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$_tok;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["["] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying repeated subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{expr})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_list, 0, 1, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_list]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_list(?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{list},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{list},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: [''(' gen expr gen ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{list},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{list},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{list},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{list},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{list},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::nl
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"nl"};

    Parse::RecDescent::_trace(q{Trying rule: [nl]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{nl},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{gen});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{nl},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{nl});
        %item = (__RULE__ => q{nl});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{nl},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\n".("   " x $indent)] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{nl},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{nl},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{nl},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{nl},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{nl},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{nl},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{nl},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::numeral
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"numeral"};

    Parse::RecDescent::_trace(q{Trying rule: [numeral]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{numeral},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)/ gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{numeral},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{numeral});
        %item = (__RULE__ => q{numeral});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)/]}, Parse::RecDescent::_tracefirst($text),
                      q{numeral},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:-?(?:\d+(?:\.\d*)?|\.\d+))/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{numeral},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$item[-1]] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{numeral},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{numeral},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)/ gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{numeral},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{numeral},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{numeral},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{numeral},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{numeral},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::paramdef
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"paramdef"};

    Parse::RecDescent::_trace(q{Trying rule: [paramdef]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/SF-\\w+/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/SF-\\w+/ nl gen gen string gen '"TRUE"', or '"FALSE"', or expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{paramdef});
        %item = (__RULE__ => q{paramdef});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/SF-\\w+/]}, Parse::RecDescent::_tracefirst($text),
                      q{paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:SF-\w+)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{paramdef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["["] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{paramdef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [$sf2pf{$item[1]}] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{paramdef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [string]},
                  Parse::RecDescent::_tracefirst($text),
                  q{paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{string})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::string($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [string]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{paramdef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [string]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{string}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [sf2pf($item[-1])."$item[-1], "] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{paramdef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_paramdef]},
                  Parse::RecDescent::_tracefirst($text),
                  q{paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{'"TRUE"', or '"FALSE"', or expr})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_paramdef($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_paramdef]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{paramdef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_paramdef]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_paramdef}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{paramdef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["],"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{paramdef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [/SF-\\w+/ nl gen gen string gen '"TRUE"', or '"FALSE"', or expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{paramdef},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{paramdef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{paramdef},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{paramdef},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::pardef
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"pardef"};

    Parse::RecDescent::_trace(q{Trying rule: [pardef]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{pardef},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{ident});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [ident gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{pardef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{pardef});
        %item = (__RULE__ => q{pardef});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [ident]},
                  Parse::RecDescent::_tracefirst($text),
                  q{pardef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::ident($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [ident]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{pardef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [ident]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{pardef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{ident}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{pardef},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return ["\$$item[-1]"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{pardef},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{pardef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [ident gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{pardef},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{pardef},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{pardef},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{pardef},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{pardef},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::pdbfun
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"pdbfun"};

    Parse::RecDescent::_trace(q{Trying rule: [pdbfun]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{pdbfun},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/gimp-|plug-in-|script-fu-|file-|extension-/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/gimp-|plug-in-|script-fu-|file-|extension-/]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{pdbfun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{pdbfun});
        %item = (__RULE__ => q{pdbfun});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/gimp-|plug-in-|script-fu-|file-|extension-/]}, Parse::RecDescent::_tracefirst($text),
                      q{pdbfun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:gimp-|plug-in-|script-fu-|file-|extension-)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: [/gimp-|plug-in-|script-fu-|file-|extension-/]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{pdbfun},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{pdbfun},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{pdbfun},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{pdbfun},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{pdbfun},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::script
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"script"};

    Parse::RecDescent::_trace(q{Trying rule: [script]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{script},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/$/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/$/ nl /$/]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{script},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{script});
        %item = (__RULE__ => q{script});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying repeated subrule: [/$/]},
                  Parse::RecDescent::_tracefirst($text),
                  q{script},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_script, 1, 100000000, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [/$/]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{script},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_script]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{script},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_script(s)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{Trying subrule: [nl]},
                  Parse::RecDescent::_tracefirst($text),
                  q{script},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{nl})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::nl($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [nl]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{script},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [nl]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{script},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{nl}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [/$/]}, Parse::RecDescent::_tracefirst($text),
                      q{script},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{/$/})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:$)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: [/$/ nl /$/]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{script},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [<error...>]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{script},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        
        my $_savetext;
        @item = (q{script});
        %item = (__RULE__ => q{script});
        my $repcount = 0;


        

        Parse::RecDescent::_trace(q{Trying directive: [<error...>]},
                    Parse::RecDescent::_tracefirst($text),
                      q{script},
                      $tracelevel)
                        if defined $::RD_TRACE; 
        $_tok = do { if (1) { do {push @{$thisparser->{errors}}, [qq{unable to recognize next statement},$thisline];} unless  $_noactions; undef } else {0} };
        if (defined($_tok))
        {
            Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
                        . $_tok . q{])},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        else
        {
            Parse::RecDescent::_trace(q{<<Didn't match directive>>},
                        Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        }
        
        last unless defined $_tok;
        push @item, $item{__DIRECTIVE1__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Matched production: [<error...>]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{script},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{script},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{script},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{script},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{script},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::skip
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"skip"};

    Parse::RecDescent::_trace(q{Trying rule: [skip]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{skip},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: []},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{skip},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{skip});
        %item = (__RULE__ => q{skip});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying action},
                      Parse::RecDescent::_tracefirst($text),
                      q{skip},
                      $tracelevel)
                        if defined $::RD_TRACE;
        

        $_tok = ($_noactions) ? 0 : do { $xskip++ };
        unless (defined $_tok)
        {
            Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
                    if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
                      . $_tok . q{])},
                      Parse::RecDescent::_tracefirst($text))
                        if defined $::RD_TRACE;
        push @item, $_tok;
        $item{__ACTION1__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Matched production: []<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{skip},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{skip},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{skip},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{skip},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{skip},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::stmt
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"stmt"};

    Parse::RecDescent::_trace(q{Trying rule: [stmt]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{stmt},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{'(', or expr});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: ['(' command ')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{stmt},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{stmt});
        %item = (__RULE__ => q{stmt});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: ['(']},
                      Parse::RecDescent::_tracefirst($text),
                      q{stmt},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\(/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying subrule: [command]},
                  Parse::RecDescent::_tracefirst($text),
                  q{stmt},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{command})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::command($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [command]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{stmt},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [command]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{stmt},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{command}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying terminal: [')']},
                      Parse::RecDescent::_tracefirst($text),
                      q{stmt},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{')'})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A\)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            
            $expectation->failed();
            Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                            if defined $::RD_TRACE;
        push @item, $item{__STRING2__}=$current_match;
        

        Parse::RecDescent::_trace(q{>>Matched production: ['(' command ')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{stmt},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [expr gen]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{stmt},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{stmt});
        %item = (__RULE__ => q{stmt});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying subrule: [expr]},
                  Parse::RecDescent::_tracefirst($text),
                  q{stmt},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::expr($thisparser,$text,$repeating,$_noactions,sub { \@arg },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [expr]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{stmt},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [expr]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{stmt},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{expr}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{Trying subrule: [gen]},
                  Parse::RecDescent::_tracefirst($text),
                  q{stmt},
                  $tracelevel)
                    if defined $::RD_TRACE;
        if (1) { no strict qw{refs};
        $expectation->is(q{gen})->at($text);
        unless (defined ($_tok = Parse::RecDescent::ScmToPerl::Grammar::gen($thisparser,$text,$repeating,$_noactions,sub { return [";"] },undef)))
        {
            
            Parse::RecDescent::_trace(q{<<Didn't match subrule: [gen]>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{stmt},
                          $tracelevel)
                            if defined $::RD_TRACE;
            $expectation->failed();
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched subrule: [gen]<< (return value: [}
                    . $_tok . q{]},

                      Parse::RecDescent::_tracefirst($text),
                      q{stmt},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{gen}} = $_tok;
        push @item, $_tok;
        
        }

        Parse::RecDescent::_trace(q{>>Matched production: [expr gen]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{stmt},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{stmt},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{stmt},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{stmt},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{stmt},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::stmts
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"stmts"};

    Parse::RecDescent::_trace(q{Trying rule: [stmts]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{stmts},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{')'});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [')']},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{stmts},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{stmts});
        %item = (__RULE__ => q{stmts});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying repeated subrule: [')']},
                  Parse::RecDescent::_tracefirst($text),
                  q{stmts},
                  $tracelevel)
                    if defined $::RD_TRACE;
        $expectation->is(q{})->at($text);
        
        unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::ScmToPerl::Grammar::_alternation_1_of_production_1_of_rule_stmts, 0, 100000000, $_noactions,$expectation,sub { \@arg },undef)))
        {
            Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [')']>>},
                          Parse::RecDescent::_tracefirst($text),
                          q{stmts},
                          $tracelevel)
                            if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_stmts]<< (}
                    . @$_tok . q{ times)},

                      Parse::RecDescent::_tracefirst($text),
                      q{stmts},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $item{q{_alternation_1_of_production_1_of_rule_stmts(s?)}} = $_tok;
        push @item, $_tok;
        


        Parse::RecDescent::_trace(q{>>Matched production: [')']<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{stmts},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{stmts},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{stmts},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{stmts},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{stmts},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::string
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"string"};

    Parse::RecDescent::_trace(q{Trying rule: [string]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{string},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{/"([^\\\\"]+|\\\\.)*"/, or /'[A-Za-z0-9-_*!?<>=\\/]+/});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/"([^\\\\"]+|\\\\.)*"/]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{string},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{string});
        %item = (__RULE__ => q{string});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/"([^\\\\"]+|\\\\.)*"/]}, Parse::RecDescent::_tracefirst($text),
                      q{string},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:"([^\\"]+|\\.)*")/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying action},
                      Parse::RecDescent::_tracefirst($text),
                      q{string},
                      $tracelevel)
                        if defined $::RD_TRACE;
        

        $_tok = ($_noactions) ? 0 : do { $item[1]=~s/([\$\@])/\\$1/g; $item[1] };
        unless (defined $_tok)
        {
            Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
                    if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
                      . $_tok . q{])},
                      Parse::RecDescent::_tracefirst($text))
                        if defined $::RD_TRACE;
        push @item, $_tok;
        $item{__ACTION1__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Matched production: [/"([^\\\\"]+|\\\\.)*"/]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{string},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: [/'[A-Za-z0-9-_*!?<>=\\/]+/]},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{string},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[1];
        $text = $_[1];
        my $_savetext;
        @item = (q{string});
        %item = (__RULE__ => q{string});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying terminal: [/'[A-Za-z0-9-_*!?<>=\\/]+/]}, Parse::RecDescent::_tracefirst($text),
                      q{string},
                      $tracelevel)
                        if defined $::RD_TRACE;
        undef $lastsep;
        $expectation->is(q{})->at($text);
        

        unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ m/\A(?:'[A-Za-z0-9-_*!?<>=\/]+)/)
        {
            $text = $lastsep . $text if defined $lastsep;
            $expectation->failed();
            Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;

            last;
        }
        $current_match = substr($text, $-[0], $+[0] - $-[0]);
        substr($text,0,length($current_match),q{});
        Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
                        . $current_match . q{])},
                          Parse::RecDescent::_tracefirst($text))
                    if defined $::RD_TRACE;
        push @item, $item{__PATTERN1__}=$current_match;
        

        Parse::RecDescent::_trace(q{Trying action},
                      Parse::RecDescent::_tracefirst($text),
                      q{string},
                      $tracelevel)
                        if defined $::RD_TRACE;
        

        $_tok = ($_noactions) ? 0 : do { $item[1]=~s/([\$\@])/\\$1/g; '"'.substr($item[1],1).'"' };
        unless (defined $_tok)
        {
            Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
                    if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
                      . $_tok . q{])},
                      Parse::RecDescent::_tracefirst($text))
                        if defined $::RD_TRACE;
        push @item, $_tok;
        $item{__ACTION1__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Matched production: [/'[A-Za-z0-9-_*!?<>=\\/]+/]<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{string},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{string},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{string},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{string},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{string},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args, $_itempos)
sub Parse::RecDescent::ScmToPerl::Grammar::unskip
{
	my $thisparser = $_[0];
	use vars q{$tracelevel};
	local $tracelevel = ($tracelevel||0)+1;
	$ERRORS = 0;
    my $thisrule = $thisparser->{"rules"}{"unskip"};

    Parse::RecDescent::_trace(q{Trying rule: [unskip]},
                  Parse::RecDescent::_tracefirst($_[1]),
                  q{unskip},
                  $tracelevel)
                    if defined $::RD_TRACE;

    my $def_at = @{$thisparser->{deferred}};
    my $err_at = @{$thisparser->{errors}};

    my $score;
    my $score_return;
    my $_tok;
    my $return = undef;
    my $_matched=0;
    my $commit=0;
    my @item = ();
    my %item = ();
    my $repeating =  $_[2];
    my $_noactions = $_[3];
    my @arg =    defined $_[4] ? @{ &{$_[4]} } : ();
    my $_itempos = $_[5];
    my %arg =    ($#arg & 01) ? @arg : (@arg, undef);
    my $text;
    my $lastsep;
    my $current_match;
    my $expectation = new Parse::RecDescent::Expectation(q{});
    $expectation->at($_[1]);
    
    my $thisoffset;
    tie $thisoffset, q{Parse::RecDescent::OffsetCounter}, \$text, $thisparser;
    
    my $thisline;
    tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;

    

    while (!$_matched && !$commit)
    {
        
        Parse::RecDescent::_trace(q{Trying production: []},
                      Parse::RecDescent::_tracefirst($_[1]),
                      q{unskip},
                      $tracelevel)
                        if defined $::RD_TRACE;
        my $thisprod = $thisrule->{"prods"}[0];
        $text = $_[1];
        my $_savetext;
        @item = (q{unskip});
        %item = (__RULE__ => q{unskip});
        my $repcount = 0;


        Parse::RecDescent::_trace(q{Trying action},
                      Parse::RecDescent::_tracefirst($text),
                      q{unskip},
                      $tracelevel)
                        if defined $::RD_TRACE;
        

        $_tok = ($_noactions) ? 0 : do { $xskip-- };
        unless (defined $_tok)
        {
            Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
                    if defined $::RD_TRACE;
            last;
        }
        Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
                      . $_tok . q{])},
                      Parse::RecDescent::_tracefirst($text))
                        if defined $::RD_TRACE;
        push @item, $_tok;
        $item{__ACTION1__}=$_tok;
        

        Parse::RecDescent::_trace(q{>>Matched production: []<<},
                      Parse::RecDescent::_tracefirst($text),
                      q{unskip},
                      $tracelevel)
                        if defined $::RD_TRACE;



        $_matched = 1;
        last;
    }

     splice
                @{$thisparser->{deferred}}, $def_at unless $_matched;
                  
    unless ( $_matched || defined($score) )
    {
             splice @{$thisparser->{deferred}}, $def_at;
              

        $_[1] = $text;  # NOT SURE THIS IS NEEDED
        Parse::RecDescent::_trace(q{<<Didn't match rule>>},
                     Parse::RecDescent::_tracefirst($_[1]),
                     q{unskip},
                     $tracelevel)
                    if defined $::RD_TRACE;
        return undef;
    }
    if (!defined($return) && defined($score))
    {
        Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
                      q{unskip},
                      $tracelevel)
                        if defined $::RD_TRACE;
        $return = $score_return;
    }
    splice @{$thisparser->{errors}}, $err_at;
    $return = $item[$#item] unless defined $return;
    if (defined $::RD_TRACE)
    {
        Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
                      $return . q{])}, "",
                      q{unskip},
                      $tracelevel);
        Parse::RecDescent::_trace(q{(consumed: [} .
                      Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
                      Parse::RecDescent::_tracefirst($text),
                      , q{unskip},
                      $tracelevel)
    }
    $_[1] = $text;
    return $return;
}
}
package ScmToPerl::Grammar; sub new { my $self = bless( {
                 '_AUTOACTION' => undef,
                 '_AUTOTREE' => undef,
                 '_check' => {
                               'itempos' => '',
                               'prevcolumn' => '',
                               'prevline' => '',
                               'prevoffset' => '',
                               'thiscolumn' => '',
                               'thisoffset' => 1
                             },
                 'deferrable' => 1,
                 'localvars' => '',
                 'namespace' => 'Parse::RecDescent::ScmToPerl::Grammar',
                 'rules' => {
                              '_alternation_1_of_production_17_of_rule_cp_expr' => bless( {
                                                                                            'calls' => [
                                                                                                         'gen',
                                                                                                         'expr'
                                                                                                       ],
                                                                                            'changed' => 0,
                                                                                            'impcount' => 0,
                                                                                            'line' => 349,
                                                                                            'name' => '_alternation_1_of_production_17_of_rule_cp_expr',
                                                                                            'opcount' => 0,
                                                                                            'prods' => [
                                                                                                         bless( {
                                                                                                                  'actcount' => 0,
                                                                                                                  'dircount' => 0,
                                                                                                                  'error' => undef,
                                                                                                                  'items' => [
                                                                                                                               bless( {
                                                                                                                                        'description' => '\')\'',
                                                                                                                                        'hashname' => '__STRING1__',
                                                                                                                                        'line' => 349,
                                                                                                                                        'lookahead' => -1,
                                                                                                                                        'pattern' => ')'
                                                                                                                                      }, 'Parse::RecDescent::Literal' ),
                                                                                                                               bless( {
                                                                                                                                        'argcode' => '["."]',
                                                                                                                                        'implicit' => undef,
                                                                                                                                        'line' => 349,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'matchrule' => 0,
                                                                                                                                        'subrule' => 'gen'
                                                                                                                                      }, 'Parse::RecDescent::Subrule' ),
                                                                                                                               bless( {
                                                                                                                                        'argcode' => undef,
                                                                                                                                        'implicit' => undef,
                                                                                                                                        'line' => 349,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'matchrule' => 0,
                                                                                                                                        'subrule' => 'expr'
                                                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                                                             ],
                                                                                                                  'line' => undef,
                                                                                                                  'number' => 0,
                                                                                                                  'patcount' => 0,
                                                                                                                  'strcount' => 1,
                                                                                                                  'uncommit' => undef
                                                                                                                }, 'Parse::RecDescent::Production' )
                                                                                                       ],
                                                                                            'vars' => ''
                                                                                          }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_19_of_rule_cp_expr' => bless( {
                                                                                            'calls' => [
                                                                                                         'gen',
                                                                                                         'expr'
                                                                                                       ],
                                                                                            'changed' => 0,
                                                                                            'impcount' => 0,
                                                                                            'line' => 349,
                                                                                            'name' => '_alternation_1_of_production_19_of_rule_cp_expr',
                                                                                            'opcount' => 0,
                                                                                            'prods' => [
                                                                                                         bless( {
                                                                                                                  'actcount' => 0,
                                                                                                                  'dircount' => 0,
                                                                                                                  'error' => undef,
                                                                                                                  'items' => [
                                                                                                                               bless( {
                                                                                                                                        'argcode' => '[","]',
                                                                                                                                        'implicit' => undef,
                                                                                                                                        'line' => 349,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'matchrule' => 0,
                                                                                                                                        'subrule' => 'gen'
                                                                                                                                      }, 'Parse::RecDescent::Subrule' ),
                                                                                                                               bless( {
                                                                                                                                        'argcode' => undef,
                                                                                                                                        'implicit' => undef,
                                                                                                                                        'line' => 349,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'matchrule' => 0,
                                                                                                                                        'subrule' => 'expr'
                                                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                                                             ],
                                                                                                                  'line' => undef,
                                                                                                                  'number' => 0,
                                                                                                                  'patcount' => 0,
                                                                                                                  'strcount' => 0,
                                                                                                                  'uncommit' => undef
                                                                                                                }, 'Parse::RecDescent::Production' )
                                                                                                       ],
                                                                                            'vars' => ''
                                                                                          }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun' => bless( {
                                                                                                                                  'calls' => [
                                                                                                                                               'gen',
                                                                                                                                               'pardef'
                                                                                                                                             ],
                                                                                                                                  'changed' => 0,
                                                                                                                                  'impcount' => 0,
                                                                                                                                  'line' => 349,
                                                                                                                                  'name' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun',
                                                                                                                                  'opcount' => 0,
                                                                                                                                  'prods' => [
                                                                                                                                               bless( {
                                                                                                                                                        'actcount' => 0,
                                                                                                                                                        'dircount' => 0,
                                                                                                                                                        'error' => undef,
                                                                                                                                                        'items' => [
                                                                                                                                                                     bless( {
                                                                                                                                                                              'description' => '\')\'',
                                                                                                                                                                              'hashname' => '__STRING1__',
                                                                                                                                                                              'line' => 349,
                                                                                                                                                                              'lookahead' => -1,
                                                                                                                                                                              'pattern' => ')'
                                                                                                                                                                            }, 'Parse::RecDescent::Literal' ),
                                                                                                                                                                     bless( {
                                                                                                                                                                              'argcode' => '[", "]',
                                                                                                                                                                              'implicit' => undef,
                                                                                                                                                                              'line' => 349,
                                                                                                                                                                              'lookahead' => 0,
                                                                                                                                                                              'matchrule' => 0,
                                                                                                                                                                              'subrule' => 'gen'
                                                                                                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                     bless( {
                                                                                                                                                                              'argcode' => undef,
                                                                                                                                                                              'implicit' => undef,
                                                                                                                                                                              'line' => 349,
                                                                                                                                                                              'lookahead' => 0,
                                                                                                                                                                              'matchrule' => 0,
                                                                                                                                                                              'subrule' => 'pardef'
                                                                                                                                                                            }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                   ],
                                                                                                                                                        'line' => undef,
                                                                                                                                                        'number' => 0,
                                                                                                                                                        'patcount' => 0,
                                                                                                                                                        'strcount' => 1,
                                                                                                                                                        'uncommit' => undef
                                                                                                                                                      }, 'Parse::RecDescent::Production' )
                                                                                                                                             ],
                                                                                                                                  'vars' => ''
                                                                                                                                }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list' => bless( {
                                                                                                                                 'calls' => [
                                                                                                                                              'gen',
                                                                                                                                              'expr'
                                                                                                                                            ],
                                                                                                                                 'changed' => 0,
                                                                                                                                 'impcount' => 0,
                                                                                                                                 'line' => 349,
                                                                                                                                 'name' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list',
                                                                                                                                 'opcount' => 0,
                                                                                                                                 'prods' => [
                                                                                                                                              bless( {
                                                                                                                                                       'actcount' => 0,
                                                                                                                                                       'dircount' => 0,
                                                                                                                                                       'error' => undef,
                                                                                                                                                       'items' => [
                                                                                                                                                                    bless( {
                                                                                                                                                                             'description' => '\')\'',
                                                                                                                                                                             'hashname' => '__STRING1__',
                                                                                                                                                                             'line' => 349,
                                                                                                                                                                             'lookahead' => -1,
                                                                                                                                                                             'pattern' => ')'
                                                                                                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                                                                                                    bless( {
                                                                                                                                                                             'argcode' => '[", "]',
                                                                                                                                                                             'implicit' => undef,
                                                                                                                                                                             'line' => 349,
                                                                                                                                                                             'lookahead' => 0,
                                                                                                                                                                             'matchrule' => 0,
                                                                                                                                                                             'subrule' => 'gen'
                                                                                                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                    bless( {
                                                                                                                                                                             'argcode' => undef,
                                                                                                                                                                             'implicit' => undef,
                                                                                                                                                                             'line' => 349,
                                                                                                                                                                             'lookahead' => 0,
                                                                                                                                                                             'matchrule' => 0,
                                                                                                                                                                             'subrule' => 'expr'
                                                                                                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                  ],
                                                                                                                                                       'line' => undef,
                                                                                                                                                       'number' => 0,
                                                                                                                                                       'patcount' => 0,
                                                                                                                                                       'strcount' => 1,
                                                                                                                                                       'uncommit' => undef
                                                                                                                                                     }, 'Parse::RecDescent::Production' )
                                                                                                                                            ],
                                                                                                                                 'vars' => ''
                                                                                                                               }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list' => bless( {
                                                                                                                               'calls' => [
                                                                                                                                            'gen',
                                                                                                                                            'expr'
                                                                                                                                          ],
                                                                                                                               'changed' => 0,
                                                                                                                               'impcount' => 0,
                                                                                                                               'line' => 349,
                                                                                                                               'name' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list',
                                                                                                                               'opcount' => 0,
                                                                                                                               'prods' => [
                                                                                                                                            bless( {
                                                                                                                                                     'actcount' => 0,
                                                                                                                                                     'dircount' => 0,
                                                                                                                                                     'error' => undef,
                                                                                                                                                     'items' => [
                                                                                                                                                                  bless( {
                                                                                                                                                                           'description' => '\')\'',
                                                                                                                                                                           'hashname' => '__STRING1__',
                                                                                                                                                                           'line' => 349,
                                                                                                                                                                           'lookahead' => -1,
                                                                                                                                                                           'pattern' => ')'
                                                                                                                                                                         }, 'Parse::RecDescent::Literal' ),
                                                                                                                                                                  bless( {
                                                                                                                                                                           'argcode' => '[", "]',
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'line' => 349,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'subrule' => 'gen'
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                  bless( {
                                                                                                                                                                           'argcode' => undef,
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'line' => 349,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'subrule' => 'expr'
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                ],
                                                                                                                                                     'line' => undef,
                                                                                                                                                     'number' => 0,
                                                                                                                                                     'patcount' => 0,
                                                                                                                                                     'strcount' => 1,
                                                                                                                                                     'uncommit' => undef
                                                                                                                                                   }, 'Parse::RecDescent::Production' )
                                                                                                                                          ],
                                                                                                                               'vars' => ''
                                                                                                                             }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call' => bless( {
                                                                                                                                 'calls' => [
                                                                                                                                              'gen',
                                                                                                                                              'expr'
                                                                                                                                            ],
                                                                                                                                 'changed' => 0,
                                                                                                                                 'impcount' => 0,
                                                                                                                                 'line' => 349,
                                                                                                                                 'name' => '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call',
                                                                                                                                 'opcount' => 0,
                                                                                                                                 'prods' => [
                                                                                                                                              bless( {
                                                                                                                                                       'actcount' => 0,
                                                                                                                                                       'dircount' => 0,
                                                                                                                                                       'error' => undef,
                                                                                                                                                       'items' => [
                                                                                                                                                                    bless( {
                                                                                                                                                                             'description' => '\')\'',
                                                                                                                                                                             'hashname' => '__STRING1__',
                                                                                                                                                                             'line' => 349,
                                                                                                                                                                             'lookahead' => -1,
                                                                                                                                                                             'pattern' => ')'
                                                                                                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                                                                                                    bless( {
                                                                                                                                                                             'argcode' => '[", "]',
                                                                                                                                                                             'implicit' => undef,
                                                                                                                                                                             'line' => 349,
                                                                                                                                                                             'lookahead' => 0,
                                                                                                                                                                             'matchrule' => 0,
                                                                                                                                                                             'subrule' => 'gen'
                                                                                                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                    bless( {
                                                                                                                                                                             'argcode' => undef,
                                                                                                                                                                             'implicit' => undef,
                                                                                                                                                                             'line' => 349,
                                                                                                                                                                             'lookahead' => 0,
                                                                                                                                                                             'matchrule' => 0,
                                                                                                                                                                             'subrule' => 'expr'
                                                                                                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                  ],
                                                                                                                                                       'line' => undef,
                                                                                                                                                       'number' => 0,
                                                                                                                                                       'patcount' => 0,
                                                                                                                                                       'strcount' => 1,
                                                                                                                                                       'uncommit' => undef
                                                                                                                                                     }, 'Parse::RecDescent::Production' )
                                                                                                                                            ],
                                                                                                                                 'vars' => ''
                                                                                                                               }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_c_defun' => bless( {
                                                                                           'calls' => [
                                                                                                        'gen',
                                                                                                        'pardef',
                                                                                                        '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun'
                                                                                                      ],
                                                                                           'changed' => 0,
                                                                                           'impcount' => 1,
                                                                                           'line' => 345,
                                                                                           'name' => '_alternation_1_of_production_1_of_rule_c_defun',
                                                                                           'opcount' => 0,
                                                                                           'prods' => [
                                                                                                        bless( {
                                                                                                                 'actcount' => 0,
                                                                                                                 'dircount' => 0,
                                                                                                                 'error' => undef,
                                                                                                                 'items' => [
                                                                                                                              bless( {
                                                                                                                                       'description' => '\')\'',
                                                                                                                                       'hashname' => '__STRING1__',
                                                                                                                                       'line' => 345,
                                                                                                                                       'lookahead' => -1,
                                                                                                                                       'pattern' => ')'
                                                                                                                                     }, 'Parse::RecDescent::Literal' ),
                                                                                                                              bless( {
                                                                                                                                       'argcode' => '["my ("]',
                                                                                                                                       'implicit' => undef,
                                                                                                                                       'line' => 346,
                                                                                                                                       'lookahead' => 0,
                                                                                                                                       'matchrule' => 0,
                                                                                                                                       'subrule' => 'gen'
                                                                                                                                     }, 'Parse::RecDescent::Subrule' ),
                                                                                                                              bless( {
                                                                                                                                       'argcode' => undef,
                                                                                                                                       'implicit' => undef,
                                                                                                                                       'line' => 347,
                                                                                                                                       'lookahead' => 0,
                                                                                                                                       'matchrule' => 0,
                                                                                                                                       'subrule' => 'pardef'
                                                                                                                                     }, 'Parse::RecDescent::Subrule' ),
                                                                                                                              bless( {
                                                                                                                                       'argcode' => undef,
                                                                                                                                       'expected' => '\')\'',
                                                                                                                                       'line' => 347,
                                                                                                                                       'lookahead' => 0,
                                                                                                                                       'matchrule' => 0,
                                                                                                                                       'max' => 100000000,
                                                                                                                                       'min' => 0,
                                                                                                                                       'repspec' => 's?',
                                                                                                                                       'subrule' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_c_defun'
                                                                                                                                     }, 'Parse::RecDescent::Repetition' ),
                                                                                                                              bless( {
                                                                                                                                       'argcode' => '[") = \\@_;"]',
                                                                                                                                       'implicit' => undef,
                                                                                                                                       'line' => 348,
                                                                                                                                       'lookahead' => 0,
                                                                                                                                       'matchrule' => 0,
                                                                                                                                       'subrule' => 'gen'
                                                                                                                                     }, 'Parse::RecDescent::Subrule' )
                                                                                                                            ],
                                                                                                                 'line' => undef,
                                                                                                                 'number' => 0,
                                                                                                                 'patcount' => 0,
                                                                                                                 'strcount' => 1,
                                                                                                                 'uncommit' => undef
                                                                                                               }, 'Parse::RecDescent::Production' )
                                                                                                      ],
                                                                                           'vars' => ''
                                                                                         }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_c_if' => bless( {
                                                                                        'calls' => [
                                                                                                     '_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if'
                                                                                                   ],
                                                                                        'changed' => 0,
                                                                                        'impcount' => 1,
                                                                                        'line' => 342,
                                                                                        'name' => '_alternation_1_of_production_1_of_rule_c_if',
                                                                                        'opcount' => 0,
                                                                                        'prods' => [
                                                                                                     bless( {
                                                                                                              'actcount' => 0,
                                                                                                              'dircount' => 0,
                                                                                                              'error' => undef,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'description' => '\'(\'',
                                                                                                                                    'hashname' => '__STRING1__',
                                                                                                                                    'line' => 342,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'pattern' => '('
                                                                                                                                  }, 'Parse::RecDescent::Literal' ),
                                                                                                                           bless( {
                                                                                                                                    'description' => '\')\'',
                                                                                                                                    'hashname' => '__STRING2__',
                                                                                                                                    'line' => 342,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'pattern' => ')'
                                                                                                                                  }, 'Parse::RecDescent::Literal' )
                                                                                                                         ],
                                                                                                              'line' => undef,
                                                                                                              'number' => 0,
                                                                                                              'patcount' => 0,
                                                                                                              'strcount' => 2,
                                                                                                              'uncommit' => undef
                                                                                                            }, 'Parse::RecDescent::Production' ),
                                                                                                     bless( {
                                                                                                              'actcount' => 0,
                                                                                                              'dircount' => 0,
                                                                                                              'error' => undef,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'expected' => '\')\'',
                                                                                                                                    'line' => 348,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'max' => 1,
                                                                                                                                    'min' => 0,
                                                                                                                                    'repspec' => '?',
                                                                                                                                    'subrule' => '_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if'
                                                                                                                                  }, 'Parse::RecDescent::Repetition' )
                                                                                                                         ],
                                                                                                              'line' => 343,
                                                                                                              'number' => 1,
                                                                                                              'patcount' => 0,
                                                                                                              'strcount' => 0,
                                                                                                              'uncommit' => undef
                                                                                                            }, 'Parse::RecDescent::Production' )
                                                                                                   ],
                                                                                        'vars' => ''
                                                                                      }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_c_let' => bless( {
                                                                                         'calls' => [
                                                                                                      'expr',
                                                                                                      'gen'
                                                                                                    ],
                                                                                         'changed' => 0,
                                                                                         'impcount' => 0,
                                                                                         'line' => 349,
                                                                                         'name' => '_alternation_1_of_production_1_of_rule_c_let',
                                                                                         'opcount' => 0,
                                                                                         'prods' => [
                                                                                                      bless( {
                                                                                                               'actcount' => 0,
                                                                                                               'dircount' => 0,
                                                                                                               'error' => undef,
                                                                                                               'items' => [
                                                                                                                            bless( {
                                                                                                                                     'argcode' => undef,
                                                                                                                                     'implicit' => undef,
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => 0,
                                                                                                                                     'matchrule' => 0,
                                                                                                                                     'subrule' => 'expr'
                                                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                                                            bless( {
                                                                                                                                     'argcode' => '[";"]',
                                                                                                                                     'implicit' => undef,
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => 0,
                                                                                                                                     'matchrule' => 0,
                                                                                                                                     'subrule' => 'gen'
                                                                                                                                   }, 'Parse::RecDescent::Subrule' )
                                                                                                                          ],
                                                                                                               'line' => undef,
                                                                                                               'number' => 0,
                                                                                                               'patcount' => 0,
                                                                                                               'strcount' => 0,
                                                                                                               'uncommit' => undef
                                                                                                             }, 'Parse::RecDescent::Production' )
                                                                                                    ],
                                                                                         'vars' => ''
                                                                                       }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_c_reg' => bless( {
                                                                                         'calls' => [
                                                                                                      'skip',
                                                                                                      'paramdef',
                                                                                                      'unskip'
                                                                                                    ],
                                                                                         'changed' => 0,
                                                                                         'impcount' => 0,
                                                                                         'line' => 349,
                                                                                         'name' => '_alternation_1_of_production_1_of_rule_c_reg',
                                                                                         'opcount' => 0,
                                                                                         'prods' => [
                                                                                                      bless( {
                                                                                                               'actcount' => 0,
                                                                                                               'dircount' => 1,
                                                                                                               'error' => undef,
                                                                                                               'items' => [
                                                                                                                            bless( {
                                                                                                                                     'code' => '($arg[0]!~/^.<Image>/) ? undef : 1',
                                                                                                                                     'hashname' => '__DIRECTIVE1__',
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => 0,
                                                                                                                                     'name' => '<reject:$arg[0]!~/^.<Image>/>'
                                                                                                                                   }, 'Parse::RecDescent::Directive' ),
                                                                                                                            bless( {
                                                                                                                                     'argcode' => undef,
                                                                                                                                     'implicit' => undef,
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => 0,
                                                                                                                                     'matchrule' => 0,
                                                                                                                                     'subrule' => 'skip'
                                                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                                                            bless( {
                                                                                                                                     'argcode' => undef,
                                                                                                                                     'implicit' => undef,
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => 0,
                                                                                                                                     'matchrule' => 0,
                                                                                                                                     'subrule' => 'paramdef'
                                                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                                                            bless( {
                                                                                                                                     'argcode' => undef,
                                                                                                                                     'implicit' => undef,
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => 0,
                                                                                                                                     'matchrule' => 0,
                                                                                                                                     'subrule' => 'paramdef'
                                                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                                                            bless( {
                                                                                                                                     'argcode' => undef,
                                                                                                                                     'implicit' => undef,
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => 0,
                                                                                                                                     'matchrule' => 0,
                                                                                                                                     'subrule' => 'unskip'
                                                                                                                                   }, 'Parse::RecDescent::Subrule' )
                                                                                                                          ],
                                                                                                               'line' => undef,
                                                                                                               'number' => 0,
                                                                                                               'patcount' => 0,
                                                                                                               'strcount' => 0,
                                                                                                               'uncommit' => undef
                                                                                                             }, 'Parse::RecDescent::Production' )
                                                                                                    ],
                                                                                         'vars' => ''
                                                                                       }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_cond' => bless( {
                                                                                        'calls' => [
                                                                                                     'expr',
                                                                                                     'gen',
                                                                                                     'incindent',
                                                                                                     'nl',
                                                                                                     'decindent',
                                                                                                     '_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond'
                                                                                                   ],
                                                                                        'changed' => 0,
                                                                                        'impcount' => 1,
                                                                                        'line' => 346,
                                                                                        'name' => '_alternation_1_of_production_1_of_rule_cond',
                                                                                        'opcount' => 0,
                                                                                        'prods' => [
                                                                                                     bless( {
                                                                                                              'actcount' => 0,
                                                                                                              'dircount' => 0,
                                                                                                              'error' => undef,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'description' => '/\'?else\\\\b/',
                                                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                                                    'ldelim' => '/',
                                                                                                                                    'line' => 346,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'mod' => '',
                                                                                                                                    'pattern' => '\'?else\\b',
                                                                                                                                    'rdelim' => '/'
                                                                                                                                  }, 'Parse::RecDescent::Token' ),
                                                                                                                           bless( {
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'implicit' => undef,
                                                                                                                                    'line' => 346,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'subrule' => 'expr'
                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                           bless( {
                                                                                                                                    'description' => '\')\'',
                                                                                                                                    'hashname' => '__STRING1__',
                                                                                                                                    'line' => 346,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'pattern' => ')'
                                                                                                                                  }, 'Parse::RecDescent::Literal' )
                                                                                                                         ],
                                                                                                              'line' => undef,
                                                                                                              'number' => 0,
                                                                                                              'patcount' => 1,
                                                                                                              'strcount' => 1,
                                                                                                              'uncommit' => undef
                                                                                                            }, 'Parse::RecDescent::Production' ),
                                                                                                     bless( {
                                                                                                              'actcount' => 0,
                                                                                                              'dircount' => 0,
                                                                                                              'error' => undef,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'implicit' => undef,
                                                                                                                                    'line' => 347,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'subrule' => 'expr'
                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                           bless( {
                                                                                                                                    'argcode' => '[" ? "]',
                                                                                                                                    'implicit' => undef,
                                                                                                                                    'line' => 347,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'subrule' => 'gen'
                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                           bless( {
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'implicit' => undef,
                                                                                                                                    'line' => 347,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'subrule' => 'expr'
                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                           bless( {
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'implicit' => undef,
                                                                                                                                    'line' => 347,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'subrule' => 'incindent'
                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                           bless( {
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'implicit' => undef,
                                                                                                                                    'line' => 347,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'subrule' => 'nl'
                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                           bless( {
                                                                                                                                    'argcode' => '[": "]',
                                                                                                                                    'implicit' => undef,
                                                                                                                                    'line' => 347,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'subrule' => 'gen'
                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                           bless( {
                                                                                                                                    'description' => '\')\'',
                                                                                                                                    'hashname' => '__STRING1__',
                                                                                                                                    'line' => 347,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'pattern' => ')'
                                                                                                                                  }, 'Parse::RecDescent::Literal' ),
                                                                                                                           bless( {
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'implicit' => undef,
                                                                                                                                    'line' => 347,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'subrule' => 'decindent'
                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                           bless( {
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'implicit' => '\'(\', or gen',
                                                                                                                                    'line' => 348,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'subrule' => '_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond'
                                                                                                                                  }, 'Parse::RecDescent::Subrule' )
                                                                                                                         ],
                                                                                                              'line' => 347,
                                                                                                              'number' => 1,
                                                                                                              'patcount' => 0,
                                                                                                              'strcount' => 1,
                                                                                                              'uncommit' => undef
                                                                                                            }, 'Parse::RecDescent::Production' )
                                                                                                   ],
                                                                                        'vars' => ''
                                                                                      }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_e_binop' => bless( {
                                                                                           'calls' => [
                                                                                                        'gen',
                                                                                                        'expr'
                                                                                                      ],
                                                                                           'changed' => 0,
                                                                                           'impcount' => 0,
                                                                                           'line' => 346,
                                                                                           'name' => '_alternation_1_of_production_1_of_rule_e_binop',
                                                                                           'opcount' => 0,
                                                                                           'prods' => [
                                                                                                        bless( {
                                                                                                                 'actcount' => 0,
                                                                                                                 'dircount' => 0,
                                                                                                                 'error' => undef,
                                                                                                                 'items' => [
                                                                                                                              bless( {
                                                                                                                                       'description' => '\')\'',
                                                                                                                                       'hashname' => '__STRING1__',
                                                                                                                                       'line' => 346,
                                                                                                                                       'lookahead' => -1,
                                                                                                                                       'pattern' => ')'
                                                                                                                                     }, 'Parse::RecDescent::Literal' ),
                                                                                                                              bless( {
                                                                                                                                       'argcode' => '[" $arg[0] "]',
                                                                                                                                       'implicit' => undef,
                                                                                                                                       'line' => 347,
                                                                                                                                       'lookahead' => 0,
                                                                                                                                       'matchrule' => 0,
                                                                                                                                       'subrule' => 'gen'
                                                                                                                                     }, 'Parse::RecDescent::Subrule' ),
                                                                                                                              bless( {
                                                                                                                                       'argcode' => undef,
                                                                                                                                       'implicit' => undef,
                                                                                                                                       'line' => 348,
                                                                                                                                       'lookahead' => 0,
                                                                                                                                       'matchrule' => 0,
                                                                                                                                       'subrule' => 'expr'
                                                                                                                                     }, 'Parse::RecDescent::Subrule' )
                                                                                                                            ],
                                                                                                                 'line' => undef,
                                                                                                                 'number' => 0,
                                                                                                                 'patcount' => 0,
                                                                                                                 'strcount' => 1,
                                                                                                                 'uncommit' => undef
                                                                                                               }, 'Parse::RecDescent::Production' )
                                                                                                      ],
                                                                                           'vars' => ''
                                                                                         }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_e_call' => bless( {
                                                                                          'calls' => [
                                                                                                       'gen',
                                                                                                       'ident'
                                                                                                     ],
                                                                                          'changed' => 0,
                                                                                          'impcount' => 0,
                                                                                          'line' => 346,
                                                                                          'name' => '_alternation_1_of_production_1_of_rule_e_call',
                                                                                          'opcount' => 0,
                                                                                          'prods' => [
                                                                                                       bless( {
                                                                                                                'actcount' => 0,
                                                                                                                'dircount' => 0,
                                                                                                                'error' => undef,
                                                                                                                'items' => [
                                                                                                                             bless( {
                                                                                                                                      'description' => '/script-fu-[A-Za-z_*][A-Za-z0-9-_*]*/',
                                                                                                                                      'hashname' => '__PATTERN1__',
                                                                                                                                      'ldelim' => '/',
                                                                                                                                      'line' => 346,
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'mod' => '',
                                                                                                                                      'pattern' => 'script-fu-[A-Za-z_*][A-Za-z0-9-_*]*',
                                                                                                                                      'rdelim' => '/'
                                                                                                                                    }, 'Parse::RecDescent::Token' ),
                                                                                                                             bless( {
                                                                                                                                      'argcode' => '["\\"$item[-1]\\"->(RUN_NONINTERACTIVE, "]',
                                                                                                                                      'implicit' => undef,
                                                                                                                                      'line' => 347,
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'matchrule' => 0,
                                                                                                                                      'subrule' => 'gen'
                                                                                                                                    }, 'Parse::RecDescent::Subrule' )
                                                                                                                           ],
                                                                                                                'line' => undef,
                                                                                                                'number' => 0,
                                                                                                                'patcount' => 1,
                                                                                                                'strcount' => 0,
                                                                                                                'uncommit' => undef
                                                                                                              }, 'Parse::RecDescent::Production' ),
                                                                                                       bless( {
                                                                                                                'actcount' => 0,
                                                                                                                'dircount' => 0,
                                                                                                                'error' => undef,
                                                                                                                'items' => [
                                                                                                                             bless( {
                                                                                                                                      'argcode' => undef,
                                                                                                                                      'implicit' => undef,
                                                                                                                                      'line' => 348,
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'matchrule' => 0,
                                                                                                                                      'subrule' => 'ident'
                                                                                                                                    }, 'Parse::RecDescent::Subrule' ),
                                                                                                                             bless( {
                                                                                                                                      'argcode' => '["$item[-1] ("]',
                                                                                                                                      'implicit' => undef,
                                                                                                                                      'line' => 348,
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'matchrule' => 0,
                                                                                                                                      'subrule' => 'gen'
                                                                                                                                    }, 'Parse::RecDescent::Subrule' )
                                                                                                                           ],
                                                                                                                'line' => 348,
                                                                                                                'number' => 1,
                                                                                                                'patcount' => 0,
                                                                                                                'strcount' => 0,
                                                                                                                'uncommit' => undef
                                                                                                              }, 'Parse::RecDescent::Production' )
                                                                                                     ],
                                                                                          'vars' => ''
                                                                                        }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_e_list' => bless( {
                                                                                          'calls' => [
                                                                                                       'expr',
                                                                                                       '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list'
                                                                                                     ],
                                                                                          'changed' => 0,
                                                                                          'impcount' => 1,
                                                                                          'line' => 349,
                                                                                          'name' => '_alternation_1_of_production_1_of_rule_e_list',
                                                                                          'opcount' => 0,
                                                                                          'prods' => [
                                                                                                       bless( {
                                                                                                                'actcount' => 0,
                                                                                                                'dircount' => 0,
                                                                                                                'error' => undef,
                                                                                                                'items' => [
                                                                                                                             bless( {
                                                                                                                                      'argcode' => undef,
                                                                                                                                      'implicit' => undef,
                                                                                                                                      'line' => 349,
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'matchrule' => 0,
                                                                                                                                      'subrule' => 'expr'
                                                                                                                                    }, 'Parse::RecDescent::Subrule' ),
                                                                                                                             bless( {
                                                                                                                                      'argcode' => undef,
                                                                                                                                      'expected' => '\')\'',
                                                                                                                                      'line' => 349,
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'matchrule' => 0,
                                                                                                                                      'max' => 100000000,
                                                                                                                                      'min' => 0,
                                                                                                                                      'repspec' => 's?',
                                                                                                                                      'subrule' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_e_list'
                                                                                                                                    }, 'Parse::RecDescent::Repetition' )
                                                                                                                           ],
                                                                                                                'line' => undef,
                                                                                                                'number' => 0,
                                                                                                                'patcount' => 0,
                                                                                                                'strcount' => 0,
                                                                                                                'uncommit' => undef
                                                                                                              }, 'Parse::RecDescent::Production' )
                                                                                                     ],
                                                                                          'vars' => ''
                                                                                        }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_gen' => bless( {
                                                                                       'calls' => [],
                                                                                       'changed' => 0,
                                                                                       'impcount' => 0,
                                                                                       'line' => 349,
                                                                                       'name' => '_alternation_1_of_production_1_of_rule_gen',
                                                                                       'opcount' => 0,
                                                                                       'prods' => [
                                                                                                    bless( {
                                                                                                             'actcount' => 0,
                                                                                                             'dircount' => 2,
                                                                                                             'error' => undef,
                                                                                                             'items' => [
                                                                                                                          bless( {
                                                                                                                                   'code' => '($xskip) ? undef : 1',
                                                                                                                                   'hashname' => '__DIRECTIVE1__',
                                                                                                                                   'line' => 349,
                                                                                                                                   'lookahead' => 0,
                                                                                                                                   'name' => '<reject:$xskip>'
                                                                                                                                 }, 'Parse::RecDescent::Directive' ),
                                                                                                                          bless( {
                                                                                                                                   'code' => 'push @{$thisparser->{deferred}}, sub {  print ::OUT $arg[0]  };',
                                                                                                                                   'hashname' => '__DIRECTIVE2__',
                                                                                                                                   'line' => 349,
                                                                                                                                   'lookahead' => 0,
                                                                                                                                   'name' => '<defer:{  print ::OUT $arg[0]  }>'
                                                                                                                                 }, 'Parse::RecDescent::Directive' )
                                                                                                                        ],
                                                                                                             'line' => undef,
                                                                                                             'number' => 0,
                                                                                                             'patcount' => 0,
                                                                                                             'strcount' => 0,
                                                                                                             'uncommit' => undef
                                                                                                           }, 'Parse::RecDescent::Production' )
                                                                                                  ],
                                                                                       'vars' => ''
                                                                                     }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_list' => bless( {
                                                                                        'calls' => [
                                                                                                     'expr',
                                                                                                     '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list'
                                                                                                   ],
                                                                                        'changed' => 0,
                                                                                        'impcount' => 1,
                                                                                        'line' => 349,
                                                                                        'name' => '_alternation_1_of_production_1_of_rule_list',
                                                                                        'opcount' => 0,
                                                                                        'prods' => [
                                                                                                     bless( {
                                                                                                              'actcount' => 0,
                                                                                                              'dircount' => 0,
                                                                                                              'error' => undef,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'implicit' => undef,
                                                                                                                                    'line' => 349,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'subrule' => 'expr'
                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                           bless( {
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'expected' => '\')\'',
                                                                                                                                    'line' => 349,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'max' => 100000000,
                                                                                                                                    'min' => 0,
                                                                                                                                    'repspec' => 's?',
                                                                                                                                    'subrule' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_list'
                                                                                                                                  }, 'Parse::RecDescent::Repetition' )
                                                                                                                         ],
                                                                                                              'line' => undef,
                                                                                                              'number' => 0,
                                                                                                              'patcount' => 0,
                                                                                                              'strcount' => 0,
                                                                                                              'uncommit' => undef
                                                                                                            }, 'Parse::RecDescent::Production' )
                                                                                                   ],
                                                                                        'vars' => ''
                                                                                      }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_paramdef' => bless( {
                                                                                            'calls' => [
                                                                                                         'gen',
                                                                                                         'expr'
                                                                                                       ],
                                                                                            'changed' => 0,
                                                                                            'impcount' => 0,
                                                                                            'line' => 346,
                                                                                            'name' => '_alternation_1_of_production_1_of_rule_paramdef',
                                                                                            'opcount' => 0,
                                                                                            'prods' => [
                                                                                                         bless( {
                                                                                                                  'actcount' => 0,
                                                                                                                  'dircount' => 0,
                                                                                                                  'error' => undef,
                                                                                                                  'items' => [
                                                                                                                               bless( {
                                                                                                                                        'description' => '\'"TRUE"\'',
                                                                                                                                        'hashname' => '__STRING1__',
                                                                                                                                        'line' => 346,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'pattern' => '"TRUE"'
                                                                                                                                      }, 'Parse::RecDescent::Literal' ),
                                                                                                                               bless( {
                                                                                                                                        'argcode' => '["1"]',
                                                                                                                                        'implicit' => undef,
                                                                                                                                        'line' => 346,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'matchrule' => 0,
                                                                                                                                        'subrule' => 'gen'
                                                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                                                             ],
                                                                                                                  'line' => undef,
                                                                                                                  'number' => 0,
                                                                                                                  'patcount' => 0,
                                                                                                                  'strcount' => 1,
                                                                                                                  'uncommit' => undef
                                                                                                                }, 'Parse::RecDescent::Production' ),
                                                                                                         bless( {
                                                                                                                  'actcount' => 0,
                                                                                                                  'dircount' => 0,
                                                                                                                  'error' => undef,
                                                                                                                  'items' => [
                                                                                                                               bless( {
                                                                                                                                        'description' => '\'"FALSE"\'',
                                                                                                                                        'hashname' => '__STRING1__',
                                                                                                                                        'line' => 347,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'pattern' => '"FALSE"'
                                                                                                                                      }, 'Parse::RecDescent::Literal' ),
                                                                                                                               bless( {
                                                                                                                                        'argcode' => '["0"]',
                                                                                                                                        'implicit' => undef,
                                                                                                                                        'line' => 347,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'matchrule' => 0,
                                                                                                                                        'subrule' => 'gen'
                                                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                                                             ],
                                                                                                                  'line' => 347,
                                                                                                                  'number' => 1,
                                                                                                                  'patcount' => 0,
                                                                                                                  'strcount' => 1,
                                                                                                                  'uncommit' => undef
                                                                                                                }, 'Parse::RecDescent::Production' ),
                                                                                                         bless( {
                                                                                                                  'actcount' => 0,
                                                                                                                  'dircount' => 0,
                                                                                                                  'error' => undef,
                                                                                                                  'items' => [
                                                                                                                               bless( {
                                                                                                                                        'argcode' => undef,
                                                                                                                                        'implicit' => undef,
                                                                                                                                        'line' => 348,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'matchrule' => 0,
                                                                                                                                        'subrule' => 'expr'
                                                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                                                             ],
                                                                                                                  'line' => 348,
                                                                                                                  'number' => 2,
                                                                                                                  'patcount' => 0,
                                                                                                                  'strcount' => 0,
                                                                                                                  'uncommit' => undef
                                                                                                                }, 'Parse::RecDescent::Production' )
                                                                                                       ],
                                                                                            'vars' => ''
                                                                                          }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_script' => bless( {
                                                                                          'calls' => [
                                                                                                       'stmt'
                                                                                                     ],
                                                                                          'changed' => 0,
                                                                                          'impcount' => 0,
                                                                                          'line' => 349,
                                                                                          'name' => '_alternation_1_of_production_1_of_rule_script',
                                                                                          'opcount' => 0,
                                                                                          'prods' => [
                                                                                                       bless( {
                                                                                                                'actcount' => 0,
                                                                                                                'dircount' => 0,
                                                                                                                'error' => undef,
                                                                                                                'items' => [
                                                                                                                             bless( {
                                                                                                                                      'description' => '/$/',
                                                                                                                                      'hashname' => '__PATTERN1__',
                                                                                                                                      'ldelim' => '/',
                                                                                                                                      'line' => 349,
                                                                                                                                      'lookahead' => -1,
                                                                                                                                      'mod' => '',
                                                                                                                                      'pattern' => '$',
                                                                                                                                      'rdelim' => '/'
                                                                                                                                    }, 'Parse::RecDescent::Token' ),
                                                                                                                             bless( {
                                                                                                                                      'argcode' => undef,
                                                                                                                                      'implicit' => undef,
                                                                                                                                      'line' => 349,
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'matchrule' => 0,
                                                                                                                                      'subrule' => 'stmt'
                                                                                                                                    }, 'Parse::RecDescent::Subrule' )
                                                                                                                           ],
                                                                                                                'line' => undef,
                                                                                                                'number' => 0,
                                                                                                                'patcount' => 1,
                                                                                                                'strcount' => 0,
                                                                                                                'uncommit' => undef
                                                                                                              }, 'Parse::RecDescent::Production' )
                                                                                                     ],
                                                                                          'vars' => ''
                                                                                        }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_stmts' => bless( {
                                                                                         'calls' => [
                                                                                                      'nl',
                                                                                                      'stmt'
                                                                                                    ],
                                                                                         'changed' => 0,
                                                                                         'impcount' => 0,
                                                                                         'line' => 349,
                                                                                         'name' => '_alternation_1_of_production_1_of_rule_stmts',
                                                                                         'opcount' => 0,
                                                                                         'prods' => [
                                                                                                      bless( {
                                                                                                               'actcount' => 0,
                                                                                                               'dircount' => 0,
                                                                                                               'error' => undef,
                                                                                                               'items' => [
                                                                                                                            bless( {
                                                                                                                                     'description' => '\')\'',
                                                                                                                                     'hashname' => '__STRING1__',
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => -1,
                                                                                                                                     'pattern' => ')'
                                                                                                                                   }, 'Parse::RecDescent::Literal' ),
                                                                                                                            bless( {
                                                                                                                                     'argcode' => undef,
                                                                                                                                     'implicit' => undef,
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => 0,
                                                                                                                                     'matchrule' => 0,
                                                                                                                                     'subrule' => 'nl'
                                                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                                                            bless( {
                                                                                                                                     'argcode' => undef,
                                                                                                                                     'implicit' => undef,
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => 0,
                                                                                                                                     'matchrule' => 0,
                                                                                                                                     'subrule' => 'stmt'
                                                                                                                                   }, 'Parse::RecDescent::Subrule' )
                                                                                                                          ],
                                                                                                               'line' => undef,
                                                                                                               'number' => 0,
                                                                                                               'patcount' => 0,
                                                                                                               'strcount' => 1,
                                                                                                               'uncommit' => undef
                                                                                                             }, 'Parse::RecDescent::Production' )
                                                                                                    ],
                                                                                         'vars' => ''
                                                                                       }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if' => bless( {
                                                                                                                               'calls' => [
                                                                                                                                            'gen',
                                                                                                                                            'incindent',
                                                                                                                                            'nl',
                                                                                                                                            'stmt',
                                                                                                                                            'decindent'
                                                                                                                                          ],
                                                                                                                               'changed' => 0,
                                                                                                                               'impcount' => 0,
                                                                                                                               'line' => 345,
                                                                                                                               'name' => '_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_c_if',
                                                                                                                               'opcount' => 0,
                                                                                                                               'prods' => [
                                                                                                                                            bless( {
                                                                                                                                                     'actcount' => 0,
                                                                                                                                                     'dircount' => 0,
                                                                                                                                                     'error' => undef,
                                                                                                                                                     'items' => [
                                                                                                                                                                  bless( {
                                                                                                                                                                           'description' => '\')\'',
                                                                                                                                                                           'hashname' => '__STRING1__',
                                                                                                                                                                           'line' => 345,
                                                                                                                                                                           'lookahead' => -1,
                                                                                                                                                                           'pattern' => ')'
                                                                                                                                                                         }, 'Parse::RecDescent::Literal' ),
                                                                                                                                                                  bless( {
                                                                                                                                                                           'argcode' => '[" else {"]',
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'line' => 346,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'subrule' => 'gen'
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                  bless( {
                                                                                                                                                                           'argcode' => undef,
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'line' => 346,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'subrule' => 'incindent'
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                  bless( {
                                                                                                                                                                           'argcode' => undef,
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'line' => 347,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'subrule' => 'nl'
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                  bless( {
                                                                                                                                                                           'argcode' => undef,
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'line' => 347,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'subrule' => 'stmt'
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                  bless( {
                                                                                                                                                                           'argcode' => undef,
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'line' => 347,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'subrule' => 'decindent'
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                  bless( {
                                                                                                                                                                           'argcode' => undef,
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'line' => 348,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'subrule' => 'nl'
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                  bless( {
                                                                                                                                                                           'argcode' => '["}"]',
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'line' => 348,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'subrule' => 'gen'
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                ],
                                                                                                                                                     'line' => undef,
                                                                                                                                                     'number' => 0,
                                                                                                                                                     'patcount' => 0,
                                                                                                                                                     'strcount' => 1,
                                                                                                                                                     'uncommit' => undef
                                                                                                                                                   }, 'Parse::RecDescent::Production' )
                                                                                                                                          ],
                                                                                                                               'vars' => ''
                                                                                                                             }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond' => bless( {
                                                                                                                               'calls' => [
                                                                                                                                            'cond',
                                                                                                                                            'gen'
                                                                                                                                          ],
                                                                                                                               'changed' => 0,
                                                                                                                               'impcount' => 0,
                                                                                                                               'line' => 349,
                                                                                                                               'name' => '_alternation_1_of_production_2_of_rule__alternation_1_of_production_1_of_rule_cond',
                                                                                                                               'opcount' => 0,
                                                                                                                               'prods' => [
                                                                                                                                            bless( {
                                                                                                                                                     'actcount' => 0,
                                                                                                                                                     'dircount' => 0,
                                                                                                                                                     'error' => undef,
                                                                                                                                                     'items' => [
                                                                                                                                                                  bless( {
                                                                                                                                                                           'description' => '\'(\'',
                                                                                                                                                                           'hashname' => '__STRING1__',
                                                                                                                                                                           'line' => 349,
                                                                                                                                                                           'lookahead' => 1,
                                                                                                                                                                           'pattern' => '('
                                                                                                                                                                         }, 'Parse::RecDescent::Literal' ),
                                                                                                                                                                  bless( {
                                                                                                                                                                           'argcode' => undef,
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'line' => 349,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'subrule' => 'cond'
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                ],
                                                                                                                                                     'line' => undef,
                                                                                                                                                     'number' => 0,
                                                                                                                                                     'patcount' => 0,
                                                                                                                                                     'strcount' => 1,
                                                                                                                                                     'uncommit' => undef
                                                                                                                                                   }, 'Parse::RecDescent::Production' ),
                                                                                                                                            bless( {
                                                                                                                                                     'actcount' => 0,
                                                                                                                                                     'dircount' => 0,
                                                                                                                                                     'error' => undef,
                                                                                                                                                     'items' => [
                                                                                                                                                                  bless( {
                                                                                                                                                                           'argcode' => '["die \'cond fell off the end\'"]',
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'line' => 349,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'subrule' => 'gen'
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                ],
                                                                                                                                                     'line' => 349,
                                                                                                                                                     'number' => 1,
                                                                                                                                                     'patcount' => 0,
                                                                                                                                                     'strcount' => 0,
                                                                                                                                                     'uncommit' => undef
                                                                                                                                                   }, 'Parse::RecDescent::Production' )
                                                                                                                                          ],
                                                                                                                               'vars' => ''
                                                                                                                             }, 'Parse::RecDescent::Rule' ),
                              '_alternation_2_of_production_1_of_rule_c_reg' => bless( {
                                                                                         'calls' => [
                                                                                                      'paramdef'
                                                                                                    ],
                                                                                         'changed' => 0,
                                                                                         'impcount' => 0,
                                                                                         'line' => 349,
                                                                                         'name' => '_alternation_2_of_production_1_of_rule_c_reg',
                                                                                         'opcount' => 0,
                                                                                         'prods' => [
                                                                                                      bless( {
                                                                                                               'actcount' => 0,
                                                                                                               'dircount' => 0,
                                                                                                               'error' => undef,
                                                                                                               'items' => [
                                                                                                                            bless( {
                                                                                                                                     'description' => '\')\'',
                                                                                                                                     'hashname' => '__STRING1__',
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => -1,
                                                                                                                                     'pattern' => ')'
                                                                                                                                   }, 'Parse::RecDescent::Literal' ),
                                                                                                                            bless( {
                                                                                                                                     'argcode' => undef,
                                                                                                                                     'implicit' => undef,
                                                                                                                                     'line' => 349,
                                                                                                                                     'lookahead' => 0,
                                                                                                                                     'matchrule' => 0,
                                                                                                                                     'subrule' => 'paramdef'
                                                                                                                                   }, 'Parse::RecDescent::Subrule' )
                                                                                                                          ],
                                                                                                               'line' => undef,
                                                                                                               'number' => 0,
                                                                                                               'patcount' => 0,
                                                                                                               'strcount' => 1,
                                                                                                               'uncommit' => undef
                                                                                                             }, 'Parse::RecDescent::Production' )
                                                                                                    ],
                                                                                         'vars' => ''
                                                                                       }, 'Parse::RecDescent::Rule' ),
                              '_alternation_2_of_production_1_of_rule_e_call' => bless( {
                                                                                          'calls' => [
                                                                                                       'expr',
                                                                                                       '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call'
                                                                                                     ],
                                                                                          'changed' => 0,
                                                                                          'impcount' => 1,
                                                                                          'line' => 347,
                                                                                          'name' => '_alternation_2_of_production_1_of_rule_e_call',
                                                                                          'opcount' => 0,
                                                                                          'prods' => [
                                                                                                       bless( {
                                                                                                                'actcount' => 0,
                                                                                                                'dircount' => 0,
                                                                                                                'error' => undef,
                                                                                                                'items' => [
                                                                                                                             bless( {
                                                                                                                                      'description' => '\')\'',
                                                                                                                                      'hashname' => '__STRING1__',
                                                                                                                                      'line' => 347,
                                                                                                                                      'lookahead' => -1,
                                                                                                                                      'pattern' => ')'
                                                                                                                                    }, 'Parse::RecDescent::Literal' ),
                                                                                                                             bless( {
                                                                                                                                      'argcode' => undef,
                                                                                                                                      'implicit' => undef,
                                                                                                                                      'line' => 348,
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'matchrule' => 0,
                                                                                                                                      'subrule' => 'expr'
                                                                                                                                    }, 'Parse::RecDescent::Subrule' ),
                                                                                                                             bless( {
                                                                                                                                      'argcode' => undef,
                                                                                                                                      'expected' => '\')\'',
                                                                                                                                      'line' => 348,
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'matchrule' => 0,
                                                                                                                                      'max' => 100000000,
                                                                                                                                      'min' => 0,
                                                                                                                                      'repspec' => 's?',
                                                                                                                                      'subrule' => '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_e_call'
                                                                                                                                    }, 'Parse::RecDescent::Repetition' )
                                                                                                                           ],
                                                                                                                'line' => undef,
                                                                                                                'number' => 0,
                                                                                                                'patcount' => 0,
                                                                                                                'strcount' => 1,
                                                                                                                'uncommit' => undef
                                                                                                              }, 'Parse::RecDescent::Production' )
                                                                                                     ],
                                                                                          'vars' => ''
                                                                                        }, 'Parse::RecDescent::Rule' ),
                              'atom' => bless( {
                                                 'calls' => [
                                                              'constant',
                                                              'gen',
                                                              'ident',
                                                              'numeral',
                                                              'string',
                                                              'list'
                                                            ],
                                                 'changed' => 0,
                                                 'impcount' => 0,
                                                 'line' => 193,
                                                 'name' => 'atom',
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 193,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'constant'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => undef,
                                                                       'number' => 0,
                                                                       'patcount' => 0,
                                                                       'strcount' => 0,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'gimp-data-dir\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 194,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => 'gimp-data-dir'
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'argcode' => '["\'/usr/local/share/gimp\'"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 194,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => 194,
                                                                       'number' => 1,
                                                                       'patcount' => 0,
                                                                       'strcount' => 1,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 195,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'ident'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '["\\$$item[-1]"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 195,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => 195,
                                                                       'number' => 2,
                                                                       'patcount' => 0,
                                                                       'strcount' => 0,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 196,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'numeral'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => 196,
                                                                       'number' => 3,
                                                                       'patcount' => 0,
                                                                       'strcount' => 0,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 197,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'string'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '[$item[-1]]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 197,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => 197,
                                                                       'number' => 4,
                                                                       'patcount' => 0,
                                                                       'strcount' => 0,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 198,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'list'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => 198,
                                                                       'number' => 5,
                                                                       'patcount' => 0,
                                                                       'strcount' => 0,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'\'not-guile\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 199,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => '\'not-guile'
                                                                                           }, 'Parse::RecDescent::InterpLit' ),
                                                                                    bless( {
                                                                                             'argcode' => '["1"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 199,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => 199,
                                                                       'number' => 6,
                                                                       'patcount' => 0,
                                                                       'strcount' => 1,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'vars' => ''
                                               }, 'Parse::RecDescent::Rule' ),
                              'c_aset' => bless( {
                                                   'calls' => [
                                                                'ident',
                                                                'gen',
                                                                'expr'
                                                              ],
                                                   'changed' => 0,
                                                   'impcount' => 0,
                                                   'line' => 273,
                                                   'name' => 'c_aset',
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'actcount' => 0,
                                                                         'dircount' => 1,
                                                                         'error' => undef,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'description' => '/aset\\\\b/',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'ldelim' => '/',
                                                                                               'line' => 273,
                                                                                               'lookahead' => 0,
                                                                                               'mod' => '',
                                                                                               'pattern' => 'aset\\b',
                                                                                               'rdelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' ),
                                                                                      bless( {
                                                                                               'code' => '$commit = 1',
                                                                                               'hashname' => '__DIRECTIVE1__',
                                                                                               'line' => 273,
                                                                                               'lookahead' => 0,
                                                                                               'name' => '<commit>'
                                                                                             }, 'Parse::RecDescent::Directive' ),
                                                                                      bless( {
                                                                                               'argcode' => undef,
                                                                                               'implicit' => undef,
                                                                                               'line' => 274,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'ident'
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'argcode' => '["\\$$item[-1]\\->["]',
                                                                                               'implicit' => undef,
                                                                                               'line' => 274,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'gen'
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'argcode' => undef,
                                                                                               'implicit' => undef,
                                                                                               'line' => 274,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'expr'
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'argcode' => '["] = "]',
                                                                                               'implicit' => undef,
                                                                                               'line' => 274,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'gen'
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'argcode' => undef,
                                                                                               'implicit' => undef,
                                                                                               'line' => 274,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'expr'
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'argcode' => '[";"]',
                                                                                               'implicit' => undef,
                                                                                               'line' => 274,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'gen'
                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                    ],
                                                                         'line' => undef,
                                                                         'number' => 0,
                                                                         'patcount' => 1,
                                                                         'strcount' => 0,
                                                                         'uncommit' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'vars' => ''
                                                 }, 'Parse::RecDescent::Rule' ),
                              'c_define' => bless( {
                                                     'calls' => [
                                                                  'ident',
                                                                  'gen',
                                                                  'expr'
                                                                ],
                                                     'changed' => 0,
                                                     'impcount' => 0,
                                                     'line' => 216,
                                                     'name' => 'c_define',
                                                     'opcount' => 0,
                                                     'prods' => [
                                                                  bless( {
                                                                           'actcount' => 0,
                                                                           'dircount' => 0,
                                                                           'error' => undef,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'description' => '\'define\'',
                                                                                                 'hashname' => '__STRING1__',
                                                                                                 'line' => 218,
                                                                                                 'lookahead' => 0,
                                                                                                 'pattern' => 'define'
                                                                                               }, 'Parse::RecDescent::Literal' ),
                                                                                        bless( {
                                                                                                 'argcode' => undef,
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 218,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'ident'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => '["\\$$item[-1] = "]',
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 218,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'gen'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => undef,
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 218,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'expr'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => '[";"]',
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 218,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'gen'
                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                      ],
                                                                           'line' => undef,
                                                                           'number' => 0,
                                                                           'patcount' => 0,
                                                                           'strcount' => 1,
                                                                           'uncommit' => undef
                                                                         }, 'Parse::RecDescent::Production' )
                                                                ],
                                                     'vars' => ''
                                                   }, 'Parse::RecDescent::Rule' ),
                              'c_defun' => bless( {
                                                    'calls' => [
                                                                 'ident',
                                                                 'nl',
                                                                 'gen',
                                                                 'incindent',
                                                                 '_alternation_1_of_production_1_of_rule_c_defun',
                                                                 'stmts',
                                                                 'decindent'
                                                               ],
                                                    'changed' => 0,
                                                    'impcount' => 1,
                                                    'line' => 203,
                                                    'name' => 'c_defun',
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 1,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'define\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 203,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'define'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'description' => '\'(\'',
                                                                                                'hashname' => '__STRING2__',
                                                                                                'line' => 203,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => '('
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'code' => '$commit = 1',
                                                                                                'hashname' => '__DIRECTIVE1__',
                                                                                                'line' => 203,
                                                                                                'lookahead' => 0,
                                                                                                'name' => '<commit>'
                                                                                              }, 'Parse::RecDescent::Directive' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 203,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'ident'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 204,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'nl'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["sub $item[-2] {"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 204,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 204,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'incindent'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 205,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'nl'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'expected' => '\')\'',
                                                                                                'line' => 209,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'max' => 1,
                                                                                                'min' => 0,
                                                                                                'repspec' => '?',
                                                                                                'subrule' => '_alternation_1_of_production_1_of_rule_c_defun'
                                                                                              }, 'Parse::RecDescent::Repetition' ),
                                                                                       bless( {
                                                                                                'description' => '\')\'',
                                                                                                'hashname' => '__STRING3__',
                                                                                                'line' => 210,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => ')'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 211,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'stmts'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 211,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'decindent'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 212,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'nl'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["}"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 212,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 212,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'nl'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => undef,
                                                                          'number' => 0,
                                                                          'patcount' => 0,
                                                                          'strcount' => 3,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'vars' => ''
                                                  }, 'Parse::RecDescent::Rule' ),
                              'c_if' => bless( {
                                                 'calls' => [
                                                              'gen',
                                                              'expr',
                                                              'incindent',
                                                              'nl',
                                                              'stmt',
                                                              'decindent',
                                                              '_alternation_1_of_production_1_of_rule_c_if'
                                                            ],
                                                 'changed' => 0,
                                                 'impcount' => 1,
                                                 'line' => 292,
                                                 'name' => 'c_if',
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 1,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'if\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 292,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => 'if'
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'code' => '$commit = 1',
                                                                                             'hashname' => '__DIRECTIVE1__',
                                                                                             'line' => 292,
                                                                                             'lookahead' => 0,
                                                                                             'name' => '<commit>'
                                                                                           }, 'Parse::RecDescent::Directive' ),
                                                                                    bless( {
                                                                                             'argcode' => '["if ("]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 293,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 293,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'expr'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '[") {"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 293,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 293,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'incindent'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 294,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'nl'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 294,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'stmt'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 294,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'decindent'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 295,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'nl'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '["}"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 295,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => '\'(\', or \')\'',
                                                                                             'line' => 303,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => '_alternation_1_of_production_1_of_rule_c_if'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => undef,
                                                                       'number' => 0,
                                                                       'patcount' => 0,
                                                                       'strcount' => 1,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'vars' => ''
                                               }, 'Parse::RecDescent::Rule' ),
                              'c_let' => bless( {
                                                  'calls' => [
                                                               'gen',
                                                               'incindent',
                                                               'let_expr',
                                                               'nl',
                                                               'stmts',
                                                               '_alternation_1_of_production_1_of_rule_c_let',
                                                               'decindent'
                                                             ],
                                                  'changed' => 0,
                                                  'impcount' => 1,
                                                  'line' => 276,
                                                  'name' => 'c_let',
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'actcount' => 0,
                                                                        'dircount' => 1,
                                                                        'error' => undef,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'description' => '/let(\\\\*|rec)?/',
                                                                                              'hashname' => '__PATTERN1__',
                                                                                              'ldelim' => '/',
                                                                                              'line' => 276,
                                                                                              'lookahead' => 0,
                                                                                              'mod' => '',
                                                                                              'pattern' => 'let(\\*|rec)?',
                                                                                              'rdelim' => '/'
                                                                                            }, 'Parse::RecDescent::Token' ),
                                                                                     bless( {
                                                                                              'code' => '$commit = 1',
                                                                                              'hashname' => '__DIRECTIVE1__',
                                                                                              'line' => 276,
                                                                                              'lookahead' => 0,
                                                                                              'name' => '<commit>'
                                                                                            }, 'Parse::RecDescent::Directive' ),
                                                                                     bless( {
                                                                                              'argcode' => '["do {"]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 277,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 277,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'incindent'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'description' => '\'(\'',
                                                                                              'hashname' => '__STRING1__',
                                                                                              'line' => 278,
                                                                                              'lookahead' => 0,
                                                                                              'pattern' => '('
                                                                                            }, 'Parse::RecDescent::Literal' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'expected' => undef,
                                                                                              'line' => 278,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'max' => 100000000,
                                                                                              'min' => 1,
                                                                                              'repspec' => 's',
                                                                                              'subrule' => 'let_expr'
                                                                                            }, 'Parse::RecDescent::Repetition' ),
                                                                                     bless( {
                                                                                              'description' => '\')\'',
                                                                                              'hashname' => '__STRING2__',
                                                                                              'line' => 278,
                                                                                              'lookahead' => 0,
                                                                                              'pattern' => ')'
                                                                                            }, 'Parse::RecDescent::Literal' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 278,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 279,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'stmts'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'expected' => 'expr',
                                                                                              'line' => 279,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'max' => 1,
                                                                                              'min' => 0,
                                                                                              'repspec' => '?',
                                                                                              'subrule' => '_alternation_1_of_production_1_of_rule_c_let'
                                                                                            }, 'Parse::RecDescent::Repetition' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 279,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'decindent'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 280,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '["};"]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 280,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' )
                                                                                   ],
                                                                        'line' => undef,
                                                                        'number' => 0,
                                                                        'patcount' => 1,
                                                                        'strcount' => 2,
                                                                        'uncommit' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'vars' => ''
                                                }, 'Parse::RecDescent::Rule' ),
                              'c_reg' => bless( {
                                                  'calls' => [
                                                               'string',
                                                               'nl',
                                                               'gen',
                                                               'incindent',
                                                               '_alternation_1_of_production_1_of_rule_c_reg',
                                                               '_alternation_2_of_production_1_of_rule_c_reg',
                                                               'decindent'
                                                             ],
                                                  'changed' => 0,
                                                  'impcount' => 2,
                                                  'line' => 222,
                                                  'name' => 'c_reg',
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'actcount' => 1,
                                                                        'dircount' => 1,
                                                                        'error' => undef,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'description' => '\'script-fu-register\'',
                                                                                              'hashname' => '__STRING1__',
                                                                                              'line' => 222,
                                                                                              'lookahead' => 0,
                                                                                              'pattern' => 'script-fu-register'
                                                                                            }, 'Parse::RecDescent::Literal' ),
                                                                                     bless( {
                                                                                              'code' => '$commit = 1',
                                                                                              'hashname' => '__DIRECTIVE1__',
                                                                                              'line' => 222,
                                                                                              'lookahead' => 0,
                                                                                              'name' => '<commit>'
                                                                                            }, 'Parse::RecDescent::Directive' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 223,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'string'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 223,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'string'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 223,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'string'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 224,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'string'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 224,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'string'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 224,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'string'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 225,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'string'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'code' => '{
	    $item[1]=func2perl(substr($item[3],1,length($item[3])-2));
	    $item[3]=~s/script-fu/perl_fu/;
	    $item[3]=~y/-/_/;
	    $item[4]=~s/Script-Fu/Perl-Fu/;
	    $item[5]=~s/\\s{2,}/ /g;
	  }',
                                                                                              'hashname' => '__ACTION1__',
                                                                                              'line' => 226,
                                                                                              'lookahead' => 0
                                                                                            }, 'Parse::RecDescent::Action' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 233,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '["register "]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 233,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 233,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'incindent'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[$item[3]]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 234,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[","]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 234,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 235,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[$item[5]]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 235,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[","]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 235,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 236,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[$item[5]]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 236,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[","]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 236,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 237,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[$item[6]]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 237,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[","]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 237,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 238,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[$item[7]]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 238,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[","]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 238,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 239,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[$item[8]]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 239,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[","]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 239,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 240,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[$item[4]]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 240,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[","]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 240,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 241,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[$item[9]]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 241,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[","]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 241,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 242,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '["["]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 242,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 242,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'incindent'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[$item[4]]',
                                                                                              'expected' => '',
                                                                                              'line' => 243,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'max' => 1,
                                                                                              'min' => 0,
                                                                                              'repspec' => '?',
                                                                                              'subrule' => '_alternation_1_of_production_1_of_rule_c_reg'
                                                                                            }, 'Parse::RecDescent::Repetition' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'expected' => '\')\'',
                                                                                              'line' => 244,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'max' => 100000000,
                                                                                              'min' => 0,
                                                                                              'repspec' => 's?',
                                                                                              'subrule' => '_alternation_2_of_production_1_of_rule_c_reg'
                                                                                            }, 'Parse::RecDescent::Repetition' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 245,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'decindent'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 246,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '["],"]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 246,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 247,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'nl'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '["\\\\&$item[1];"]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 247,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 248,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'decindent'
                                                                                            }, 'Parse::RecDescent::Subrule' )
                                                                                   ],
                                                                        'line' => undef,
                                                                        'number' => 0,
                                                                        'patcount' => 0,
                                                                        'strcount' => 1,
                                                                        'uncommit' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'vars' => ''
                                                }, 'Parse::RecDescent::Rule' ),
                              'c_set' => bless( {
                                                  'calls' => [
                                                               'ident',
                                                               'gen',
                                                               'expr'
                                                             ],
                                                  'changed' => 0,
                                                  'impcount' => 0,
                                                  'line' => 268,
                                                  'name' => 'c_set',
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'actcount' => 0,
                                                                        'dircount' => 1,
                                                                        'error' => undef,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'description' => '/set!?/',
                                                                                              'hashname' => '__PATTERN1__',
                                                                                              'ldelim' => '/',
                                                                                              'line' => 268,
                                                                                              'lookahead' => 0,
                                                                                              'mod' => '',
                                                                                              'pattern' => 'set!?',
                                                                                              'rdelim' => '/'
                                                                                            }, 'Parse::RecDescent::Token' ),
                                                                                     bless( {
                                                                                              'code' => '$commit = 1',
                                                                                              'hashname' => '__DIRECTIVE1__',
                                                                                              'line' => 268,
                                                                                              'lookahead' => 0,
                                                                                              'name' => '<commit>'
                                                                                            }, 'Parse::RecDescent::Directive' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 269,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'ident'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '["\\$$item[-1] = "]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 269,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 270,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'expr'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '[";"]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 271,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' )
                                                                                   ],
                                                                        'line' => undef,
                                                                        'number' => 0,
                                                                        'patcount' => 1,
                                                                        'strcount' => 0,
                                                                        'uncommit' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'vars' => ''
                                                }, 'Parse::RecDescent::Rule' ),
                              'c_while' => bless( {
                                                    'calls' => [
                                                                 'nl',
                                                                 'gen',
                                                                 'expr',
                                                                 'incindent',
                                                                 'stmts',
                                                                 'decindent'
                                                               ],
                                                    'changed' => 0,
                                                    'impcount' => 0,
                                                    'line' => 305,
                                                    'name' => 'c_while',
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 1,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'while\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 305,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'while'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'code' => '$commit = 1',
                                                                                                'hashname' => '__DIRECTIVE1__',
                                                                                                'line' => 305,
                                                                                                'lookahead' => 0,
                                                                                                'name' => '<commit>'
                                                                                              }, 'Parse::RecDescent::Directive' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 306,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'nl'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["while ("]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 306,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 306,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[") {"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 306,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 306,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'incindent'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 307,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'stmts'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 307,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'decindent'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 308,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'nl'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["}"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 308,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => undef,
                                                                          'number' => 0,
                                                                          'patcount' => 0,
                                                                          'strcount' => 1,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'vars' => ''
                                                  }, 'Parse::RecDescent::Rule' ),
                              'command' => bless( {
                                                    'calls' => [
                                                                 'cp_expr',
                                                                 'gen',
                                                                 'c_let',
                                                                 'c_set',
                                                                 'c_if',
                                                                 'c_while',
                                                                 'e_cond',
                                                                 'c_aset',
                                                                 'c_defun',
                                                                 'c_define',
                                                                 'c_reg',
                                                                 'expr',
                                                                 'e_call',
                                                                 'atom'
                                                               ],
                                                    'changed' => 0,
                                                    'impcount' => 0,
                                                    'line' => 131,
                                                    'name' => 'command',
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 131,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'cp_expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[";"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 131,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => undef,
                                                                          'number' => 0,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 132,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'c_let'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 132,
                                                                          'number' => 1,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 133,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'c_set'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 133,
                                                                          'number' => 2,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 134,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'c_if'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 134,
                                                                          'number' => 3,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 135,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'c_while'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 135,
                                                                          'number' => 4,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 136,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'e_cond'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[";"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 136,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 136,
                                                                          'number' => 5,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 137,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'c_aset'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 137,
                                                                          'number' => 6,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 138,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'c_defun'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 138,
                                                                          'number' => 7,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 139,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'c_define'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 139,
                                                                          'number' => 8,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 140,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'c_reg'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 140,
                                                                          'number' => 9,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/print\\\\b/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 141,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'print\\b',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => '["print "]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 141,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 141,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[",\'\\n\';"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 141,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 141,
                                                                          'number' => 10,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 142,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'e_call'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[";"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 142,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 142,
                                                                          'number' => 11,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 143,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'atom'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[";"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 143,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 143,
                                                                          'number' => 12,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 1,
                                                                          'error' => 1,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'commitonly' => '',
                                                                                                'hashname' => '__DIRECTIVE1__',
                                                                                                'line' => 144,
                                                                                                'lookahead' => 0,
                                                                                                'msg' => 'unrecognized statement'
                                                                                              }, 'Parse::RecDescent::Error' )
                                                                                     ],
                                                                          'line' => 144,
                                                                          'number' => 13,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => 0
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'vars' => ''
                                                  }, 'Parse::RecDescent::Rule' ),
                              'cond' => bless( {
                                                 'calls' => [
                                                              '_alternation_1_of_production_1_of_rule_cond'
                                                            ],
                                                 'changed' => 0,
                                                 'impcount' => 1,
                                                 'line' => 313,
                                                 'name' => 'cond',
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'(\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 313,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => '('
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => '/\'?else\\\\b/, or expr',
                                                                                             'line' => 317,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => '_alternation_1_of_production_1_of_rule_cond'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => undef,
                                                                       'number' => 0,
                                                                       'patcount' => 0,
                                                                       'strcount' => 1,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'vars' => ''
                                               }, 'Parse::RecDescent::Rule' ),
                              'constant' => bless( {
                                                     'calls' => [
                                                                  'gen'
                                                                ],
                                                     'changed' => 0,
                                                     'impcount' => 0,
                                                     'line' => 337,
                                                     'name' => 'constant',
                                                     'opcount' => 0,
                                                     'prods' => [
                                                                  bless( {
                                                                           'actcount' => 0,
                                                                           'dircount' => 0,
                                                                           'error' => undef,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'description' => '/(?:$constants)(?=[ \\\\t;)\\\\n\\\\r])/',
                                                                                                 'hashname' => '__PATTERN1__',
                                                                                                 'ldelim' => '/',
                                                                                                 'line' => 337,
                                                                                                 'lookahead' => 0,
                                                                                                 'mod' => '',
                                                                                                 'pattern' => '(?:$constants)(?=[ \\t;)\\n\\r])',
                                                                                                 'rdelim' => '/'
                                                                                               }, 'Parse::RecDescent::Token' ),
                                                                                        bless( {
                                                                                                 'argcode' => '[$constant{$item[-1]}]',
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 337,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'gen'
                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                      ],
                                                                           'line' => undef,
                                                                           'number' => 0,
                                                                           'patcount' => 1,
                                                                           'strcount' => 0,
                                                                           'uncommit' => undef
                                                                         }, 'Parse::RecDescent::Production' ),
                                                                  bless( {
                                                                           'actcount' => 0,
                                                                           'dircount' => 0,
                                                                           'error' => undef,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'description' => '/[A-Z-_]\\{3,\\}/',
                                                                                                 'hashname' => '__PATTERN1__',
                                                                                                 'ldelim' => '/',
                                                                                                 'line' => 338,
                                                                                                 'lookahead' => 0,
                                                                                                 'mod' => '',
                                                                                                 'pattern' => '[A-Z-_]{3,}',
                                                                                                 'rdelim' => '/'
                                                                                               }, 'Parse::RecDescent::Token' ),
                                                                                        bless( {
                                                                                                 'argcode' => '[func2perl($item[-1])]',
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 338,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'gen'
                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                      ],
                                                                           'line' => 338,
                                                                           'number' => 1,
                                                                           'patcount' => 1,
                                                                           'strcount' => 0,
                                                                           'uncommit' => undef
                                                                         }, 'Parse::RecDescent::Production' )
                                                                ],
                                                     'vars' => ''
                                                   }, 'Parse::RecDescent::Rule' ),
                              'cp_expr' => bless( {
                                                    'calls' => [
                                                                 'pdbfun',
                                                                 'e_call',
                                                                 'e_begin',
                                                                 'e_list',
                                                                 'expr',
                                                                 'gen',
                                                                 'e_binop',
                                                                 '_alternation_1_of_production_17_of_rule_cp_expr',
                                                                 '_alternation_1_of_production_19_of_rule_cp_expr',
                                                                 'string',
                                                                 'ident',
                                                                 'cp_expr',
                                                                 'constant'
                                                               ],
                                                    'changed' => 0,
                                                    'impcount' => 0,
                                                    'line' => 155,
                                                    'name' => 'cp_expr',
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/car\\\\b/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 155,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'car\\b',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'description' => '\'(\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 155,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => '('
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 155,
                                                                                                'lookahead' => 1,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'pdbfun'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 155,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'e_call'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'description' => '\')\'',
                                                                                                'hashname' => '__STRING2__',
                                                                                                'line' => 155,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => ')'
                                                                                              }, 'Parse::RecDescent::Literal' )
                                                                                     ],
                                                                          'line' => undef,
                                                                          'number' => 0,
                                                                          'patcount' => 1,
                                                                          'strcount' => 2,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 157,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'e_begin'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 157,
                                                                          'number' => 1,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 158,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'e_list'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 158,
                                                                          'number' => 2,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'=\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 159,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => '='
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 159,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'description' => '\'TRUE\'',
                                                                                                'hashname' => '__STRING2__',
                                                                                                'line' => 159,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'TRUE'
                                                                                              }, 'Parse::RecDescent::Literal' )
                                                                                     ],
                                                                          'line' => 159,
                                                                          'number' => 3,
                                                                          'patcount' => 0,
                                                                          'strcount' => 2,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'=\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 160,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => '='
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'description' => '\'TRUE\'',
                                                                                                'hashname' => '__STRING2__',
                                                                                                'line' => 160,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'TRUE'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 160,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 160,
                                                                          'number' => 4,
                                                                          'patcount' => 0,
                                                                          'strcount' => 2,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'=\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 161,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => '='
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => '["!"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 161,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 161,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'description' => '\'FALSE\'',
                                                                                                'hashname' => '__STRING2__',
                                                                                                'line' => 161,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'FALSE'
                                                                                              }, 'Parse::RecDescent::Literal' )
                                                                                     ],
                                                                          'line' => 161,
                                                                          'number' => 5,
                                                                          'patcount' => 0,
                                                                          'strcount' => 2,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'=\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 162,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => '='
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => '["!"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 162,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'description' => '\'FALSE\'',
                                                                                                'hashname' => '__STRING2__',
                                                                                                'line' => 162,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'FALSE'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 162,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 162,
                                                                          'number' => 6,
                                                                          'patcount' => 0,
                                                                          'strcount' => 2,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'-\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 163,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => '-'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => '["-("]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 163,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 163,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'description' => '\')\'',
                                                                                                'hashname' => '__STRING2__',
                                                                                                'line' => 163,
                                                                                                'lookahead' => 1,
                                                                                                'pattern' => ')'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => '[")"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 163,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 163,
                                                                          'number' => 7,
                                                                          'patcount' => 0,
                                                                          'strcount' => 2,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => 'm\\{[-+]|and\\\\b\\}',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '{',
                                                                                                'line' => 164,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => '[-+]|and\\b',
                                                                                                'rdelim' => '}'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => '["("]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 164,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[$item[1]]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 164,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'e_binop'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[")"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 164,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 164,
                                                                          'number' => 8,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => 'm\\{<=|>=|!=|[*/<>]|or\\\\b\\}',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '{',
                                                                                                'line' => 165,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => '<=|>=|!=|[*/<>]|or\\b',
                                                                                                'rdelim' => '}'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => '[$item[1]]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 165,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'e_binop'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 165,
                                                                          'number' => 9,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'=\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 166,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => '='
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => '["=="]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 166,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'e_binop'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 166,
                                                                          'number' => 10,
                                                                          'patcount' => 0,
                                                                          'strcount' => 1,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/eq\\\\?|eqv\\\\?|equal\\\\?/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 167,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'eq\\?|eqv\\?|equal\\?',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'description' => '\'()\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 167,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => '()'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 167,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[" eq \'\'"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 167,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 167,
                                                                          'number' => 11,
                                                                          'patcount' => 1,
                                                                          'strcount' => 1,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/eq\\\\?|eqv\\\\?|equal\\\\?/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 168,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'eq\\?|eqv\\?|equal\\?',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => '["eq"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 168,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'e_binop'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 167,
                                                                          'number' => 12,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/realtime\\\\b/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 169,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'realtime\\b',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => '["time"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 169,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 169,
                                                                          'number' => 13,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/modulo\\\\b/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 170,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'modulo\\b',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 170,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[" % "]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 170,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 170,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 170,
                                                                          'number' => 14,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'divide?\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 171,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'divide?'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => '["!"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 171,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 171,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["%"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 171,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 171,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 171,
                                                                          'number' => 15,
                                                                          'patcount' => 0,
                                                                          'strcount' => 1,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'string-append\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 172,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'string-append'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 172,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'expected' => '\')\'',
                                                                                                'line' => 172,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'max' => 100000000,
                                                                                                'min' => 0,
                                                                                                'repspec' => 's?',
                                                                                                'subrule' => '_alternation_1_of_production_17_of_rule_cp_expr'
                                                                                              }, 'Parse::RecDescent::Repetition' )
                                                                                     ],
                                                                          'line' => 172,
                                                                          'number' => 16,
                                                                          'patcount' => 0,
                                                                          'strcount' => 1,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'number->string\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 173,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'number->string'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 173,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'description' => '\')\'',
                                                                                                'hashname' => '__STRING2__',
                                                                                                'line' => 173,
                                                                                                'lookahead' => 1,
                                                                                                'pattern' => ')'
                                                                                              }, 'Parse::RecDescent::Literal' )
                                                                                     ],
                                                                          'line' => 173,
                                                                          'number' => 17,
                                                                          'patcount' => 0,
                                                                          'strcount' => 2,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'cons-array\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 174,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'cons-array'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => '["("]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 174,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 174,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'expected' => 'gen',
                                                                                                'line' => 174,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'max' => 1,
                                                                                                'min' => 0,
                                                                                                'repspec' => '?',
                                                                                                'subrule' => '_alternation_1_of_production_19_of_rule_cp_expr'
                                                                                              }, 'Parse::RecDescent::Repetition' ),
                                                                                       bless( {
                                                                                                'argcode' => '[",[])"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 174,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 174,
                                                                          'number' => 18,
                                                                          'patcount' => 0,
                                                                          'strcount' => 1,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'symbol-bound?\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 175,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'symbol-bound?'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 175,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'string'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'description' => '\'(\'',
                                                                                                'hashname' => '__STRING2__',
                                                                                                'line' => 175,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => '('
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 175,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'ident'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'description' => '\')\'',
                                                                                                'hashname' => '__STRING3__',
                                                                                                'line' => 175,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => ')'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => '["0"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 175,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 175,
                                                                          'number' => 19,
                                                                          'patcount' => 0,
                                                                          'strcount' => 3,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/aref\\\\b/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 177,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'aref\\b',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 177,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["->["]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 177,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 177,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["]"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 177,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 177,
                                                                          'number' => 20,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 1,
                                                                          'dircount' => 1,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/$compat_fun/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 179,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => '$compat_fun',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'code' => '{ $::add_funcs{$compat_fun{$item[1]}}++ }',
                                                                                                'hashname' => '__ACTION1__',
                                                                                                'line' => 179,
                                                                                                'lookahead' => 0
                                                                                              }, 'Parse::RecDescent::Action' ),
                                                                                       bless( {
                                                                                                'hashname' => '__DIRECTIVE1__',
                                                                                                'line' => 179,
                                                                                                'lookahead' => 0,
                                                                                                'name' => '<reject>'
                                                                                              }, 'Parse::RecDescent::UncondReject' )
                                                                                     ],
                                                                          'line' => 179,
                                                                          'number' => 21,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/car\\\\b/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 180,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'car\\b',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => '["\\@{"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 180,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 180,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["}[0]"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 180,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 180,
                                                                          'number' => 22,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/cadr\\\\b/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 181,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'cadr\\b',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => '["\\@{"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 181,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 181,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["}[1]"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 181,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 181,
                                                                          'number' => 23,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/caddr\\\\b/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 182,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'caddr\\b',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => '["\\@{"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 182,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 182,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["}[2]"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 182,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 182,
                                                                          'number' => 24,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/cadddr\\\\b/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 183,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'cadddr\\b',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => '["\\@{"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 183,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 183,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["}[3]"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 183,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 183,
                                                                          'number' => 25,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'null?\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 184,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => 'null?'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => '["!\\@{"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 184,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 184,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["}"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 184,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 184,
                                                                          'number' => 26,
                                                                          'patcount' => 0,
                                                                          'strcount' => 1,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/cons\\\\b/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 185,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'cons\\b',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => '["["]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 185,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 185,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[", "]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 185,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 185,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["]"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 185,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 185,
                                                                          'number' => 27,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\')\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 187,
                                                                                                'lookahead' => 1,
                                                                                                'pattern' => ')'
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => '["[]"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 187,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 187,
                                                                          'number' => 28,
                                                                          'patcount' => 0,
                                                                          'strcount' => 1,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '\'(\'',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'line' => 188,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => '('
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 188,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'cp_expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'description' => '\')\'',
                                                                                                'hashname' => '__STRING2__',
                                                                                                'line' => 188,
                                                                                                'lookahead' => 0,
                                                                                                'pattern' => ')'
                                                                                              }, 'Parse::RecDescent::Literal' )
                                                                                     ],
                                                                          'line' => 188,
                                                                          'number' => 29,
                                                                          'patcount' => 0,
                                                                          'strcount' => 2,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 189,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'constant'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 189,
                                                                          'number' => 30,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'vars' => ''
                                                  }, 'Parse::RecDescent::Rule' ),
                              'decindent' => bless( {
                                                      'calls' => [],
                                                      'changed' => 0,
                                                      'impcount' => 0,
                                                      'line' => 343,
                                                      'name' => 'decindent',
                                                      'opcount' => 0,
                                                      'prods' => [
                                                                   bless( {
                                                                            'actcount' => 1,
                                                                            'dircount' => 0,
                                                                            'error' => undef,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'code' => '{ $indent-- }',
                                                                                                  'hashname' => '__ACTION1__',
                                                                                                  'line' => 343,
                                                                                                  'lookahead' => 0
                                                                                                }, 'Parse::RecDescent::Action' )
                                                                                       ],
                                                                            'line' => undef,
                                                                            'number' => 0,
                                                                            'patcount' => 0,
                                                                            'strcount' => 0,
                                                                            'uncommit' => undef
                                                                          }, 'Parse::RecDescent::Production' )
                                                                 ],
                                                      'vars' => ''
                                                    }, 'Parse::RecDescent::Rule' ),
                              'e_begin' => bless( {
                                                    'calls' => [
                                                                 'gen',
                                                                 'incindent',
                                                                 'stmts',
                                                                 'decindent',
                                                                 'nl'
                                                               ],
                                                    'changed' => 0,
                                                    'impcount' => 0,
                                                    'line' => 284,
                                                    'name' => 'e_begin',
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 1,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/begin\\\\b|prog1\\\\b/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 284,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => 'begin\\b|prog1\\b',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'code' => '$commit = 1',
                                                                                                'hashname' => '__DIRECTIVE1__',
                                                                                                'line' => 284,
                                                                                                'lookahead' => 0,
                                                                                                'name' => '<commit>'
                                                                                              }, 'Parse::RecDescent::Directive' ),
                                                                                       bless( {
                                                                                                'argcode' => '["do {"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 285,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 285,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'incindent'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 286,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'stmts'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 286,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'decindent'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 287,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'nl'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '["}"]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 287,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => undef,
                                                                          'number' => 0,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'vars' => ''
                                                  }, 'Parse::RecDescent::Rule' ),
                              'e_binop' => bless( {
                                                    'calls' => [
                                                                 'expr',
                                                                 '_alternation_1_of_production_1_of_rule_e_binop'
                                                               ],
                                                    'changed' => 0,
                                                    'impcount' => 1,
                                                    'line' => 319,
                                                    'name' => 'e_binop',
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'argcode' => undef,
                                                                                                'implicit' => undef,
                                                                                                'line' => 319,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'expr'
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'argcode' => '[@arg]',
                                                                                                'expected' => '\')\'',
                                                                                                'line' => 323,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'max' => 100000000,
                                                                                                'min' => 0,
                                                                                                'repspec' => 's?',
                                                                                                'subrule' => '_alternation_1_of_production_1_of_rule_e_binop'
                                                                                              }, 'Parse::RecDescent::Repetition' )
                                                                                     ],
                                                                          'line' => undef,
                                                                          'number' => 0,
                                                                          'patcount' => 0,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'vars' => ''
                                                  }, 'Parse::RecDescent::Rule' ),
                              'e_call' => bless( {
                                                   'calls' => [
                                                                '_alternation_1_of_production_1_of_rule_e_call',
                                                                '_alternation_2_of_production_1_of_rule_e_call',
                                                                'gen'
                                                              ],
                                                   'changed' => 0,
                                                   'impcount' => 2,
                                                   'line' => 259,
                                                   'name' => 'e_call',
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'actcount' => 0,
                                                                         'dircount' => 0,
                                                                         'error' => undef,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'argcode' => undef,
                                                                                               'implicit' => '/script-fu-[A-Za-z_*][A-Za-z0-9-_*]*/, or ident',
                                                                                               'line' => 262,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => '_alternation_1_of_production_1_of_rule_e_call'
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'argcode' => '[@arg]',
                                                                                               'expected' => '\')\'',
                                                                                               'line' => 265,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'max' => 1,
                                                                                               'min' => 0,
                                                                                               'repspec' => '?',
                                                                                               'subrule' => '_alternation_2_of_production_1_of_rule_e_call'
                                                                                             }, 'Parse::RecDescent::Repetition' ),
                                                                                      bless( {
                                                                                               'argcode' => '[")"]',
                                                                                               'implicit' => undef,
                                                                                               'line' => 266,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'gen'
                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                    ],
                                                                         'line' => undef,
                                                                         'number' => 0,
                                                                         'patcount' => 0,
                                                                         'strcount' => 0,
                                                                         'uncommit' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'vars' => ''
                                                 }, 'Parse::RecDescent::Rule' ),
                              'e_cond' => bless( {
                                                   'calls' => [
                                                                'cond'
                                                              ],
                                                   'changed' => 0,
                                                   'impcount' => 0,
                                                   'line' => 310,
                                                   'name' => 'e_cond',
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'actcount' => 0,
                                                                         'dircount' => 1,
                                                                         'error' => undef,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'description' => '\'cond\'',
                                                                                               'hashname' => '__STRING1__',
                                                                                               'line' => 310,
                                                                                               'lookahead' => 0,
                                                                                               'pattern' => 'cond'
                                                                                             }, 'Parse::RecDescent::Literal' ),
                                                                                      bless( {
                                                                                               'code' => '$commit = 1',
                                                                                               'hashname' => '__DIRECTIVE1__',
                                                                                               'line' => 310,
                                                                                               'lookahead' => 0,
                                                                                               'name' => '<commit>'
                                                                                             }, 'Parse::RecDescent::Directive' ),
                                                                                      bless( {
                                                                                               'argcode' => undef,
                                                                                               'implicit' => undef,
                                                                                               'line' => 311,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'cond'
                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                    ],
                                                                         'line' => undef,
                                                                         'number' => 0,
                                                                         'patcount' => 0,
                                                                         'strcount' => 1,
                                                                         'uncommit' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'vars' => ''
                                                 }, 'Parse::RecDescent::Rule' ),
                              'e_dot' => bless( {
                                                  'calls' => [
                                                               'expr',
                                                               'gen'
                                                             ],
                                                  'changed' => 0,
                                                  'impcount' => 0,
                                                  'line' => 201,
                                                  'name' => 'e_dot',
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'actcount' => 0,
                                                                        'dircount' => 0,
                                                                        'error' => undef,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'description' => '\'string-append\'',
                                                                                              'hashname' => '__STRING1__',
                                                                                              'line' => 201,
                                                                                              'lookahead' => 0,
                                                                                              'pattern' => 'string-append'
                                                                                            }, 'Parse::RecDescent::Literal' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 201,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'expr'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => '["."]',
                                                                                              'implicit' => undef,
                                                                                              'line' => 201,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'gen'
                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'implicit' => undef,
                                                                                              'line' => 201,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'subrule' => 'expr'
                                                                                            }, 'Parse::RecDescent::Subrule' )
                                                                                   ],
                                                                        'line' => undef,
                                                                        'number' => 0,
                                                                        'patcount' => 0,
                                                                        'strcount' => 1,
                                                                        'uncommit' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'vars' => ''
                                                }, 'Parse::RecDescent::Rule' ),
                              'e_if' => bless( {
                                                 'calls' => [
                                                              'gen',
                                                              'expr'
                                                            ],
                                                 'changed' => 0,
                                                 'impcount' => 0,
                                                 'line' => 289,
                                                 'name' => 'e_if',
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 1,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'if\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 289,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => 'if'
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'code' => '$commit = 1',
                                                                                             'hashname' => '__DIRECTIVE1__',
                                                                                             'line' => 289,
                                                                                             'lookahead' => 0,
                                                                                             'name' => '<commit>'
                                                                                           }, 'Parse::RecDescent::Directive' ),
                                                                                    bless( {
                                                                                             'argcode' => '["("]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 290,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 290,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'expr'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '[") ? ("]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 290,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 290,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'expr'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '[") : ("]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 290,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 290,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'expr'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '[")"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 290,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => undef,
                                                                       'number' => 0,
                                                                       'patcount' => 0,
                                                                       'strcount' => 1,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'vars' => ''
                                               }, 'Parse::RecDescent::Rule' ),
                              'e_list' => bless( {
                                                   'calls' => [
                                                                'gen',
                                                                '_alternation_1_of_production_1_of_rule_e_list'
                                                              ],
                                                   'changed' => 0,
                                                   'impcount' => 1,
                                                   'line' => 325,
                                                   'name' => 'e_list',
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'actcount' => 0,
                                                                         'dircount' => 0,
                                                                         'error' => undef,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'description' => '\'list\'',
                                                                                               'hashname' => '__STRING1__',
                                                                                               'line' => 325,
                                                                                               'lookahead' => 0,
                                                                                               'pattern' => 'list'
                                                                                             }, 'Parse::RecDescent::Literal' ),
                                                                                      bless( {
                                                                                               'argcode' => '["["]',
                                                                                               'implicit' => undef,
                                                                                               'line' => 325,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'gen'
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'argcode' => undef,
                                                                                               'expected' => 'expr',
                                                                                               'line' => 325,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'max' => 1,
                                                                                               'min' => 0,
                                                                                               'repspec' => '?',
                                                                                               'subrule' => '_alternation_1_of_production_1_of_rule_e_list'
                                                                                             }, 'Parse::RecDescent::Repetition' ),
                                                                                      bless( {
                                                                                               'argcode' => '["]"]',
                                                                                               'implicit' => undef,
                                                                                               'line' => 325,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'gen'
                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                    ],
                                                                         'line' => undef,
                                                                         'number' => 0,
                                                                         'patcount' => 0,
                                                                         'strcount' => 1,
                                                                         'uncommit' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'vars' => ''
                                                 }, 'Parse::RecDescent::Rule' ),
                              'expr' => bless( {
                                                 'calls' => [
                                                              'e_if',
                                                              'gen',
                                                              'e_cond',
                                                              'cp_expr',
                                                              'pdbfun',
                                                              'e_call',
                                                              'incindent',
                                                              'nl',
                                                              'command',
                                                              'decindent',
                                                              'atom'
                                                            ],
                                                 'changed' => 0,
                                                 'impcount' => 0,
                                                 'line' => 146,
                                                 'name' => 'expr',
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'(\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 146,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => '('
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 146,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'e_if'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'description' => '\')\'',
                                                                                             'hashname' => '__STRING2__',
                                                                                             'line' => 146,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => ')'
                                                                                           }, 'Parse::RecDescent::Literal' )
                                                                                  ],
                                                                       'line' => undef,
                                                                       'number' => 0,
                                                                       'patcount' => 0,
                                                                       'strcount' => 2,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'(\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 147,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => '('
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'argcode' => '["("]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 147,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 147,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'e_cond'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '[")"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 147,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'description' => '\')\'',
                                                                                             'hashname' => '__STRING2__',
                                                                                             'line' => 147,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => ')'
                                                                                           }, 'Parse::RecDescent::Literal' )
                                                                                  ],
                                                                       'line' => 147,
                                                                       'number' => 1,
                                                                       'patcount' => 0,
                                                                       'strcount' => 2,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'(\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 148,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => '('
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 148,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'cp_expr'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'description' => '\')\'',
                                                                                             'hashname' => '__STRING2__',
                                                                                             'line' => 148,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => ')'
                                                                                           }, 'Parse::RecDescent::Literal' )
                                                                                  ],
                                                                       'line' => 148,
                                                                       'number' => 2,
                                                                       'patcount' => 0,
                                                                       'strcount' => 2,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'(\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 149,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => '('
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 149,
                                                                                             'lookahead' => -1,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'pdbfun'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 149,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'e_call'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'description' => '\')\'',
                                                                                             'hashname' => '__STRING2__',
                                                                                             'line' => 149,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => ')'
                                                                                           }, 'Parse::RecDescent::Literal' )
                                                                                  ],
                                                                       'line' => 149,
                                                                       'number' => 3,
                                                                       'patcount' => 0,
                                                                       'strcount' => 2,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'(\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 150,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => '('
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 150,
                                                                                             'lookahead' => 1,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'pdbfun'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '["["]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 150,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 150,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'e_call'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '["]"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 150,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'description' => '\')\'',
                                                                                             'hashname' => '__STRING2__',
                                                                                             'line' => 150,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => ')'
                                                                                           }, 'Parse::RecDescent::Literal' )
                                                                                  ],
                                                                       'line' => 150,
                                                                       'number' => 4,
                                                                       'patcount' => 0,
                                                                       'strcount' => 2,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'(\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 151,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => '('
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'argcode' => '["do {"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 151,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 151,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'incindent'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 151,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'nl'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 151,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'command'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 151,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'decindent'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 151,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'nl'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '["}"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 151,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'description' => '\')\'',
                                                                                             'hashname' => '__STRING2__',
                                                                                             'line' => 151,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => ')'
                                                                                           }, 'Parse::RecDescent::Literal' )
                                                                                  ],
                                                                       'line' => 151,
                                                                       'number' => 5,
                                                                       'patcount' => 0,
                                                                       'strcount' => 2,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 152,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'atom'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => 152,
                                                                       'number' => 6,
                                                                       'patcount' => 0,
                                                                       'strcount' => 0,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 1,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\')\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 153,
                                                                                             'lookahead' => -1,
                                                                                             'pattern' => ')'
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'commitonly' => '',
                                                                                             'hashname' => '__DIRECTIVE1__',
                                                                                             'line' => 153,
                                                                                             'lookahead' => 0,
                                                                                             'msg' => 'unrecognized expression'
                                                                                           }, 'Parse::RecDescent::Error' )
                                                                                  ],
                                                                       'line' => 153,
                                                                       'number' => 7,
                                                                       'patcount' => 0,
                                                                       'strcount' => 1,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'vars' => ''
                                               }, 'Parse::RecDescent::Rule' ),
                              'gen' => bless( {
                                                'calls' => [
                                                             '_alternation_1_of_production_1_of_rule_gen'
                                                           ],
                                                'changed' => 0,
                                                'impcount' => 1,
                                                'line' => 346,
                                                'name' => 'gen',
                                                'opcount' => 0,
                                                'prods' => [
                                                             bless( {
                                                                      'actcount' => 0,
                                                                      'dircount' => 0,
                                                                      'error' => undef,
                                                                      'items' => [
                                                                                   bless( {
                                                                                            'argcode' => '[@arg]',
                                                                                            'expected' => '',
                                                                                            'line' => 346,
                                                                                            'lookahead' => 0,
                                                                                            'matchrule' => 0,
                                                                                            'max' => 1,
                                                                                            'min' => 0,
                                                                                            'repspec' => '?',
                                                                                            'subrule' => '_alternation_1_of_production_1_of_rule_gen'
                                                                                          }, 'Parse::RecDescent::Repetition' )
                                                                                 ],
                                                                      'line' => undef,
                                                                      'number' => 0,
                                                                      'patcount' => 0,
                                                                      'strcount' => 0,
                                                                      'uncommit' => undef
                                                                    }, 'Parse::RecDescent::Production' )
                                                           ],
                                                'vars' => ''
                                              }, 'Parse::RecDescent::Rule' ),
                              'ident' => bless( {
                                                  'calls' => [],
                                                  'changed' => 0,
                                                  'impcount' => 0,
                                                  'line' => 327,
                                                  'name' => 'ident',
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'actcount' => 1,
                                                                        'dircount' => 1,
                                                                        'error' => undef,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'description' => '/[A-Za-z0-9-#_*!?<>=\\\\/]+/',
                                                                                              'hashname' => '__PATTERN1__',
                                                                                              'ldelim' => '/',
                                                                                              'line' => 327,
                                                                                              'lookahead' => 0,
                                                                                              'mod' => '',
                                                                                              'pattern' => '[A-Za-z0-9-#_*!?<>=\\/]+',
                                                                                              'rdelim' => '/'
                                                                                            }, 'Parse::RecDescent::Token' ),
                                                                                     bless( {
                                                                                              'code' => '($item[1]!~/[A-Za-z]/) ? undef : 1',
                                                                                              'hashname' => '__DIRECTIVE1__',
                                                                                              'line' => 327,
                                                                                              'lookahead' => 0,
                                                                                              'name' => '<reject:$item[1]!~/[A-Za-z]/>'
                                                                                            }, 'Parse::RecDescent::Directive' ),
                                                                                     bless( {
                                                                                              'code' => '{ func2perl($item[1]) }',
                                                                                              'hashname' => '__ACTION1__',
                                                                                              'line' => 328,
                                                                                              'lookahead' => 0
                                                                                            }, 'Parse::RecDescent::Action' )
                                                                                   ],
                                                                        'line' => undef,
                                                                        'number' => 0,
                                                                        'patcount' => 1,
                                                                        'strcount' => 0,
                                                                        'uncommit' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'vars' => ''
                                                }, 'Parse::RecDescent::Rule' ),
                              'incindent' => bless( {
                                                      'calls' => [],
                                                      'changed' => 0,
                                                      'impcount' => 0,
                                                      'line' => 342,
                                                      'name' => 'incindent',
                                                      'opcount' => 0,
                                                      'prods' => [
                                                                   bless( {
                                                                            'actcount' => 2,
                                                                            'dircount' => 0,
                                                                            'error' => undef,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'code' => '{ printf STDERR " %2d%%\\b\\b\\b\\b",$thisoffset*100/$::filesize unless $::quiet }',
                                                                                                  'hashname' => '__ACTION1__',
                                                                                                  'line' => 342,
                                                                                                  'lookahead' => 0
                                                                                                }, 'Parse::RecDescent::Action' ),
                                                                                         bless( {
                                                                                                  'code' => '{ $indent++ }',
                                                                                                  'hashname' => '__ACTION2__',
                                                                                                  'line' => 342,
                                                                                                  'lookahead' => 0
                                                                                                }, 'Parse::RecDescent::Action' )
                                                                                       ],
                                                                            'line' => undef,
                                                                            'number' => 0,
                                                                            'patcount' => 0,
                                                                            'strcount' => 0,
                                                                            'uncommit' => undef
                                                                          }, 'Parse::RecDescent::Production' )
                                                                 ],
                                                      'vars' => ''
                                                    }, 'Parse::RecDescent::Rule' ),
                              'let_expr' => bless( {
                                                     'calls' => [
                                                                  'nl',
                                                                  'ident',
                                                                  'gen',
                                                                  'expr'
                                                                ],
                                                     'changed' => 0,
                                                     'impcount' => 0,
                                                     'line' => 282,
                                                     'name' => 'let_expr',
                                                     'opcount' => 0,
                                                     'prods' => [
                                                                  bless( {
                                                                           'actcount' => 0,
                                                                           'dircount' => 0,
                                                                           'error' => undef,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'description' => '\')\'',
                                                                                                 'hashname' => '__STRING1__',
                                                                                                 'line' => 282,
                                                                                                 'lookahead' => -1,
                                                                                                 'pattern' => ')'
                                                                                               }, 'Parse::RecDescent::Literal' ),
                                                                                        bless( {
                                                                                                 'argcode' => undef,
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 282,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'nl'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'description' => '\'(\'',
                                                                                                 'hashname' => '__STRING2__',
                                                                                                 'line' => 282,
                                                                                                 'lookahead' => 0,
                                                                                                 'pattern' => '('
                                                                                               }, 'Parse::RecDescent::Literal' ),
                                                                                        bless( {
                                                                                                 'argcode' => undef,
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 282,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'ident'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => '["my \\$$item[-1] = "]',
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 282,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'gen'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => undef,
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 282,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'expr'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => '[";"]',
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 282,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'gen'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'description' => '\')\'',
                                                                                                 'hashname' => '__STRING3__',
                                                                                                 'line' => 282,
                                                                                                 'lookahead' => 0,
                                                                                                 'pattern' => ')'
                                                                                               }, 'Parse::RecDescent::Literal' )
                                                                                      ],
                                                                           'line' => undef,
                                                                           'number' => 0,
                                                                           'patcount' => 0,
                                                                           'strcount' => 3,
                                                                           'uncommit' => undef
                                                                         }, 'Parse::RecDescent::Production' )
                                                                ],
                                                     'vars' => ''
                                                   }, 'Parse::RecDescent::Rule' ),
                              'list' => bless( {
                                                 'calls' => [
                                                              'gen',
                                                              '_alternation_1_of_production_1_of_rule_list'
                                                            ],
                                                 'changed' => 0,
                                                 'impcount' => 1,
                                                 'line' => 335,
                                                 'name' => 'list',
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'\'(\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 335,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => '\'('
                                                                                           }, 'Parse::RecDescent::InterpLit' ),
                                                                                    bless( {
                                                                                             'argcode' => '["["]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 335,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'expected' => 'expr',
                                                                                             'line' => 335,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'max' => 1,
                                                                                             'min' => 0,
                                                                                             'repspec' => '?',
                                                                                             'subrule' => '_alternation_1_of_production_1_of_rule_list'
                                                                                           }, 'Parse::RecDescent::Repetition' ),
                                                                                    bless( {
                                                                                             'argcode' => '["]"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 335,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'description' => '\')\'',
                                                                                             'hashname' => '__STRING2__',
                                                                                             'line' => 335,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => ')'
                                                                                           }, 'Parse::RecDescent::Literal' )
                                                                                  ],
                                                                       'line' => undef,
                                                                       'number' => 0,
                                                                       'patcount' => 0,
                                                                       'strcount' => 2,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'vars' => ''
                                               }, 'Parse::RecDescent::Rule' ),
                              'nl' => bless( {
                                               'calls' => [
                                                            'gen'
                                                          ],
                                               'changed' => 0,
                                               'impcount' => 0,
                                               'line' => 341,
                                               'name' => 'nl',
                                               'opcount' => 0,
                                               'prods' => [
                                                            bless( {
                                                                     'actcount' => 0,
                                                                     'dircount' => 0,
                                                                     'error' => undef,
                                                                     'items' => [
                                                                                  bless( {
                                                                                           'argcode' => '["\\n".("   " x $indent)]',
                                                                                           'implicit' => undef,
                                                                                           'line' => 341,
                                                                                           'lookahead' => 0,
                                                                                           'matchrule' => 0,
                                                                                           'subrule' => 'gen'
                                                                                         }, 'Parse::RecDescent::Subrule' )
                                                                                ],
                                                                     'line' => undef,
                                                                     'number' => 0,
                                                                     'patcount' => 0,
                                                                     'strcount' => 0,
                                                                     'uncommit' => undef
                                                                   }, 'Parse::RecDescent::Production' )
                                                          ],
                                               'vars' => ''
                                             }, 'Parse::RecDescent::Rule' ),
                              'numeral' => bless( {
                                                    'calls' => [
                                                                 'gen'
                                                               ],
                                                    'changed' => 0,
                                                    'impcount' => 0,
                                                    'line' => 330,
                                                    'name' => 'numeral',
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'actcount' => 0,
                                                                          'dircount' => 0,
                                                                          'error' => undef,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'description' => '/-?(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)/',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'ldelim' => '/',
                                                                                                'line' => 330,
                                                                                                'lookahead' => 0,
                                                                                                'mod' => '',
                                                                                                'pattern' => '-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)',
                                                                                                'rdelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'argcode' => '[$item[-1]]',
                                                                                                'implicit' => undef,
                                                                                                'line' => 330,
                                                                                                'lookahead' => 0,
                                                                                                'matchrule' => 0,
                                                                                                'subrule' => 'gen'
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => undef,
                                                                          'number' => 0,
                                                                          'patcount' => 1,
                                                                          'strcount' => 0,
                                                                          'uncommit' => undef
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'vars' => ''
                                                  }, 'Parse::RecDescent::Rule' ),
                              'paramdef' => bless( {
                                                     'calls' => [
                                                                  'nl',
                                                                  'gen',
                                                                  'string',
                                                                  '_alternation_1_of_production_1_of_rule_paramdef'
                                                                ],
                                                     'changed' => 0,
                                                     'impcount' => 1,
                                                     'line' => 250,
                                                     'name' => 'paramdef',
                                                     'opcount' => 0,
                                                     'prods' => [
                                                                  bless( {
                                                                           'actcount' => 0,
                                                                           'dircount' => 0,
                                                                           'error' => undef,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'description' => '/SF-\\\\w+/',
                                                                                                 'hashname' => '__PATTERN1__',
                                                                                                 'ldelim' => '/',
                                                                                                 'line' => 250,
                                                                                                 'lookahead' => 0,
                                                                                                 'mod' => '',
                                                                                                 'pattern' => 'SF-\\w+',
                                                                                                 'rdelim' => '/'
                                                                                               }, 'Parse::RecDescent::Token' ),
                                                                                        bless( {
                                                                                                 'argcode' => undef,
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 251,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'nl'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => '["["]',
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 252,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'gen'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => '[$sf2pf{$item[1]}]',
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 252,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'gen'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => undef,
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 253,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'string'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => '[sf2pf($item[-1])."$item[-1], "]',
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 253,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'gen'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => undef,
                                                                                                 'implicit' => '\'"TRUE"\', or \'"FALSE"\', or expr',
                                                                                                 'line' => 257,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => '_alternation_1_of_production_1_of_rule_paramdef'
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'argcode' => '["],"]',
                                                                                                 'implicit' => undef,
                                                                                                 'line' => 257,
                                                                                                 'lookahead' => 0,
                                                                                                 'matchrule' => 0,
                                                                                                 'subrule' => 'gen'
                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                      ],
                                                                           'line' => undef,
                                                                           'number' => 0,
                                                                           'patcount' => 1,
                                                                           'strcount' => 0,
                                                                           'uncommit' => undef
                                                                         }, 'Parse::RecDescent::Production' )
                                                                ],
                                                     'vars' => ''
                                                   }, 'Parse::RecDescent::Rule' ),
                              'pardef' => bless( {
                                                   'calls' => [
                                                                'ident',
                                                                'gen'
                                                              ],
                                                   'changed' => 0,
                                                   'impcount' => 0,
                                                   'line' => 220,
                                                   'name' => 'pardef',
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'actcount' => 0,
                                                                         'dircount' => 0,
                                                                         'error' => undef,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'argcode' => undef,
                                                                                               'implicit' => undef,
                                                                                               'line' => 220,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'ident'
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'argcode' => '["\\$$item[-1]"]',
                                                                                               'implicit' => undef,
                                                                                               'line' => 220,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'gen'
                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                    ],
                                                                         'line' => undef,
                                                                         'number' => 0,
                                                                         'patcount' => 0,
                                                                         'strcount' => 0,
                                                                         'uncommit' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'vars' => ''
                                                 }, 'Parse::RecDescent::Rule' ),
                              'pdbfun' => bless( {
                                                   'calls' => [],
                                                   'changed' => 0,
                                                   'impcount' => 0,
                                                   'line' => 191,
                                                   'name' => 'pdbfun',
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'actcount' => 0,
                                                                         'dircount' => 0,
                                                                         'error' => undef,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'description' => '/gimp-|plug-in-|script-fu-|file-|extension-/',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'ldelim' => '/',
                                                                                               'line' => 191,
                                                                                               'lookahead' => 0,
                                                                                               'mod' => '',
                                                                                               'pattern' => 'gimp-|plug-in-|script-fu-|file-|extension-',
                                                                                               'rdelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => undef,
                                                                         'number' => 0,
                                                                         'patcount' => 1,
                                                                         'strcount' => 0,
                                                                         'uncommit' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'vars' => ''
                                                 }, 'Parse::RecDescent::Rule' ),
                              'script' => bless( {
                                                   'calls' => [
                                                                '_alternation_1_of_production_1_of_rule_script',
                                                                'nl'
                                                              ],
                                                   'changed' => 0,
                                                   'impcount' => 0,
                                                   'line' => 123,
                                                   'name' => 'script',
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'actcount' => 0,
                                                                         'dircount' => 0,
                                                                         'error' => undef,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'argcode' => undef,
                                                                                               'expected' => '/$/',
                                                                                               'line' => 123,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'max' => 100000000,
                                                                                               'min' => 1,
                                                                                               'repspec' => 's',
                                                                                               'subrule' => '_alternation_1_of_production_1_of_rule_script'
                                                                                             }, 'Parse::RecDescent::Repetition' ),
                                                                                      bless( {
                                                                                               'argcode' => undef,
                                                                                               'implicit' => undef,
                                                                                               'line' => 123,
                                                                                               'lookahead' => 0,
                                                                                               'matchrule' => 0,
                                                                                               'subrule' => 'nl'
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'description' => '/$/',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'ldelim' => '/',
                                                                                               'line' => 123,
                                                                                               'lookahead' => 0,
                                                                                               'mod' => '',
                                                                                               'pattern' => '$',
                                                                                               'rdelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => undef,
                                                                         'number' => 0,
                                                                         'patcount' => 1,
                                                                         'strcount' => 0,
                                                                         'uncommit' => undef
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'actcount' => 0,
                                                                         'dircount' => 1,
                                                                         'error' => 1,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'commitonly' => '',
                                                                                               'hashname' => '__DIRECTIVE1__',
                                                                                               'line' => 124,
                                                                                               'lookahead' => 0,
                                                                                               'msg' => 'unable to recognize next statement'
                                                                                             }, 'Parse::RecDescent::Error' )
                                                                                    ],
                                                                         'line' => 124,
                                                                         'number' => 1,
                                                                         'patcount' => 0,
                                                                         'strcount' => 0,
                                                                         'uncommit' => 0
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'vars' => ''
                                                 }, 'Parse::RecDescent::Rule' ),
                              'skip' => bless( {
                                                 'calls' => [],
                                                 'changed' => 0,
                                                 'impcount' => 0,
                                                 'line' => 344,
                                                 'name' => 'skip',
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'actcount' => 1,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'code' => '{ $xskip++ }',
                                                                                             'hashname' => '__ACTION1__',
                                                                                             'line' => 344,
                                                                                             'lookahead' => 0
                                                                                           }, 'Parse::RecDescent::Action' )
                                                                                  ],
                                                                       'line' => undef,
                                                                       'number' => 0,
                                                                       'patcount' => 0,
                                                                       'strcount' => 0,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'vars' => ''
                                               }, 'Parse::RecDescent::Rule' ),
                              'stmt' => bless( {
                                                 'calls' => [
                                                              'command',
                                                              'expr',
                                                              'gen'
                                                            ],
                                                 'changed' => 0,
                                                 'impcount' => 0,
                                                 'line' => 128,
                                                 'name' => 'stmt',
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'description' => '\'(\'',
                                                                                             'hashname' => '__STRING1__',
                                                                                             'line' => 128,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => '('
                                                                                           }, 'Parse::RecDescent::Literal' ),
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 128,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'command'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'description' => '\')\'',
                                                                                             'hashname' => '__STRING2__',
                                                                                             'line' => 128,
                                                                                             'lookahead' => 0,
                                                                                             'pattern' => ')'
                                                                                           }, 'Parse::RecDescent::Literal' )
                                                                                  ],
                                                                       'line' => undef,
                                                                       'number' => 0,
                                                                       'patcount' => 0,
                                                                       'strcount' => 2,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'actcount' => 0,
                                                                       'dircount' => 0,
                                                                       'error' => undef,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'argcode' => undef,
                                                                                             'implicit' => undef,
                                                                                             'line' => 129,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'expr'
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'argcode' => '[";"]',
                                                                                             'implicit' => undef,
                                                                                             'line' => 129,
                                                                                             'lookahead' => 0,
                                                                                             'matchrule' => 0,
                                                                                             'subrule' => 'gen'
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => 129,
                                                                       'number' => 1,
                                                                       'patcount' => 0,
                                                                       'strcount' => 0,
                                                                       'uncommit' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'vars' => ''
                                               }, 'Parse::RecDescent::Rule' ),
                              'stmts' => bless( {
                                                  'calls' => [
                                                               '_alternation_1_of_production_1_of_rule_stmts'
                                                             ],
                                                  'changed' => 0,
                                                  'impcount' => 1,
                                                  'line' => 126,
                                                  'name' => 'stmts',
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'actcount' => 0,
                                                                        'dircount' => 0,
                                                                        'error' => undef,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'argcode' => undef,
                                                                                              'expected' => '\')\'',
                                                                                              'line' => 126,
                                                                                              'lookahead' => 0,
                                                                                              'matchrule' => 0,
                                                                                              'max' => 100000000,
                                                                                              'min' => 0,
                                                                                              'repspec' => 's?',
                                                                                              'subrule' => '_alternation_1_of_production_1_of_rule_stmts'
                                                                                            }, 'Parse::RecDescent::Repetition' )
                                                                                   ],
                                                                        'line' => undef,
                                                                        'number' => 0,
                                                                        'patcount' => 0,
                                                                        'strcount' => 0,
                                                                        'uncommit' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'vars' => ''
                                                }, 'Parse::RecDescent::Rule' ),
                              'string' => bless( {
                                                   'calls' => [],
                                                   'changed' => 0,
                                                   'impcount' => 0,
                                                   'line' => 332,
                                                   'name' => 'string',
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'actcount' => 1,
                                                                         'dircount' => 0,
                                                                         'error' => undef,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'description' => '/"([^\\\\\\\\"]+|\\\\\\\\.)*"/',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'ldelim' => '/',
                                                                                               'line' => 332,
                                                                                               'lookahead' => 0,
                                                                                               'mod' => '',
                                                                                               'pattern' => '"([^\\\\"]+|\\\\.)*"',
                                                                                               'rdelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' ),
                                                                                      bless( {
                                                                                               'code' => '{ $item[1]=~s/([\\$\\@])/\\\\$1/g; $item[1] }',
                                                                                               'hashname' => '__ACTION1__',
                                                                                               'line' => 332,
                                                                                               'lookahead' => 0
                                                                                             }, 'Parse::RecDescent::Action' )
                                                                                    ],
                                                                         'line' => undef,
                                                                         'number' => 0,
                                                                         'patcount' => 1,
                                                                         'strcount' => 0,
                                                                         'uncommit' => undef
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'actcount' => 1,
                                                                         'dircount' => 0,
                                                                         'error' => undef,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'description' => '/\'[A-Za-z0-9-_*!?<>=\\\\/]+/',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'ldelim' => '/',
                                                                                               'line' => 333,
                                                                                               'lookahead' => 0,
                                                                                               'mod' => '',
                                                                                               'pattern' => '\'[A-Za-z0-9-_*!?<>=\\/]+',
                                                                                               'rdelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' ),
                                                                                      bless( {
                                                                                               'code' => '{ $item[1]=~s/([\\$\\@])/\\\\$1/g; \'"\'.substr($item[1],1).\'"\' }',
                                                                                               'hashname' => '__ACTION1__',
                                                                                               'line' => 333,
                                                                                               'lookahead' => 0
                                                                                             }, 'Parse::RecDescent::Action' )
                                                                                    ],
                                                                         'line' => 333,
                                                                         'number' => 1,
                                                                         'patcount' => 1,
                                                                         'strcount' => 0,
                                                                         'uncommit' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'vars' => ''
                                                 }, 'Parse::RecDescent::Rule' ),
                              'unskip' => bless( {
                                                   'calls' => [],
                                                   'changed' => 0,
                                                   'impcount' => 0,
                                                   'line' => 345,
                                                   'name' => 'unskip',
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'actcount' => 1,
                                                                         'dircount' => 0,
                                                                         'error' => undef,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'code' => '{ $xskip-- }',
                                                                                               'hashname' => '__ACTION1__',
                                                                                               'line' => 345,
                                                                                               'lookahead' => 0
                                                                                             }, 'Parse::RecDescent::Action' )
                                                                                    ],
                                                                         'line' => undef,
                                                                         'number' => 0,
                                                                         'patcount' => 0,
                                                                         'strcount' => 0,
                                                                         'uncommit' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'vars' => ''
                                                 }, 'Parse::RecDescent::Rule' )
                            },
                 'startcode' => ''
               }, 'Parse::RecDescent' );
}